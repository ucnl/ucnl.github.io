
[Главная](/README_RU) ❯ [Наши проекты для образования](/educational_projects_ru) ❯ **ACubes: Руководство пользователя**

<div style="page-break-after: always;"></div>

| ![logo](/documentation/sm_logo.png) | ![image](https://github.com/user-attachments/assets/f9be473c-561b-4536-8c0b-7ab44e6598aa) |
| :---: | ---: |
| [www.unavlab.com](https://www.unavlab.com/) <br/> [support@unavlab.com](mailto:support@unavlab.com) | **A<sup>3</sup>S** **ACubes** <br/> Руководство пользователя |


# Семейство устройств **A<sup>3</sup>S** <br/> Руководство пользователя

<div style="page-break-after: always;"></div>

## Содержание

* [0. Для кого и зачем эта коробка с кубиками?](#0-для-кого-и-зачем-эта-коробка-с-кубиками)
* [1. A³T и A³R](#1-a3t-и-a3r)
  * [Передатчик A³T](#передатчик-a3t)
  * [Приёмник A³R](#приёмник-a3r)
  * [Особенности работы](#особенности-работы)
  * [Возможности масштабирования](#возможности-масштабирования)
  * [1.1. О гидроакустических антеннах](#11-о-гидроакустических-антеннах)
    * [Особенности выбора антенн](#особенности-выбора-антенн)
    * [Специализированные приёмные антенны](#специализированные-приёмные-антенны)
    * [Приёмо-передающие антенны](#приёмо-передающие-антенны)
    * [Правила эксплуатации](#правила-эксплуатации)
  * [1.2. Проект 1 - Передаем и принимаем](#12-проект-1---передаем-и-принимаем)
    * [1.2.1. Требуемый набор оборудования](#121-требуемый-набор-оборудования)
    * [Подключение антенн](#подключение-антенн)
    * [1.2.2. Настройка передатчика](#122-настройка-передатчика)
    * [1.2.3. Настройка приёмника](#123-настройка-приёмника)
    * [1.2.4. Тестирование системы](#124-тестирование-системы)
  * [1.3. Кратко о многолучевости и защитных интервалах](#13-кратко-о-многолучевости-и-защитных-интервалах)
    * [1.3.1. Суть явления многолучевости](#131-суть-явления-многолучевости)
    * [1.3.2. Проблемы, вызванные многолучевостью](#132-проблемы-вызванные-многолучевостью)
    * [1.3.3. Методы борьбы (на примере ACubes)](#133-методы-борьбы-на-примере-acubes)
  * [1.4. Проект 2 - Собираем приемопередатчик и измеряем наклонную дальность](#14-проект-2---собираем-приемопередатчик-и-измеряем-наклонную-дальность)
    * [1.4.1. Требуемый набор оборудования](#141-требуемый-набор-оборудования)
    * [1.4.2. Запрашивающее устройство](#142-запрашивающее-устройство)
      * [1.4.2.1. Скетч - Инициирует передачу и измеряет время между запросом и ответом](#1421-скетч---инициирует-передачу-и-измеряет-время-между-запросом-и-ответом)
    * [1.4.3. Маяк-ответчик. Вариант 1 - без Arduino](#143-маяк-ответчик-вариант-1---без-arduino)
    * [1.4.4. Маяк-ответчик. Вариант 2 - с Arduino и фиксированной задержкой](#144-маяк-ответчик-вариант-2---с-arduino-и-фиксированной-задержкой)
      * [1.4.4.1. Скетч - Фиксированная задержка ответа](#1441-скетч---фиксированная-задержка-ответа)
    * [1.4.5. Эксперименты](#145-эксперименты)
      * [1.4.5.1. На столе](#1451-на-столе)
      * [1.4.5.2. В тазу](#1452-в-тазу)
      * [1.4.5.3. Плавательный бассейн](#1453-плавательный-бассейн)
      * [1.4.5.4. Водоем](#1454-водоем) 
  * [1.5. Проект 3 - Гидроакустический модем](#15-проект-3---гидроакустический-модем)
    * [1.5.1. Требуемый набор оборудования](#151-требуемый-набор-оборудования)
    * [1.5.2. Подключение](#152-подключение)
    * [1.5.3. Скетч модема](#153-скетч-модема)
  * [1.6. Проект 4 - Антенная решетка: измерение угла прихода сигнала](#16-проект-4---антенная-решетка-измерение-угла-прихода-сигнала)
    * [1.6.1. (Планируется)Требуемый набор оборудования]()
  * [1.7. (Планируется) Проект 5 - Определение положения ответчика методом виртуальной длинной базы]()
    * [1.7.1. (Планируется) Требуемый набор оборудования]()
  * [1.8. (Планируется) Проект 6 - Длиннобазисная навигационная система]()
    * [1.8.1. (Планируется)Требуемый набор оборудования]()
    * [1.8.2. (Планируется)Навигационный буй-приемник]()
* [2. (Планируется) A<sup>3</sup>TC и A<sup>3</sup>RC]()
* [3. (Планируется) A<sup>3</sup>T2 и A<sup>3</sup>R2]()
* [4. (Планируется)A<sup>3</sup>AM]()



<div style="page-break-after: always;"></div>

## 0. Для кого и зачем эта коробка с кубиками?
В первую очередь ACubes задумывался для применения в сфере образования и подготовки инженерных кадров.

A³S (или ACubes, «Акустические кубики») — это конструктор, набор элементарных функциональных элементов, на основе которых можно создавать макеты практически любых типов гидроакустических навигационных систем и систем связи:

- простейшие системы передачи цифровой информации — гидроакустические модемы;
- системы для беспроводной передачи голоса;
- фазированные антенные решётки, а на их основе — ультракороткобазисные (USBL) навигационные системы с маяками-ответчиками;
- длиннобазисные, короткобазисные системы, а также системы с синтезированной измерительной базой;
- системы телеуправления;
- системы сетевого мониторинга.

«Кубики» берут на себя вопросы, связанные с преобразованием цифрового сигнала в гидроакустический и обратно, позволяя пользователю сосредоточиться на решении прикладных задач: разработке оригинальных навигационных алгоритмов, алгоритмов помехоустойчивого кодирования, сетевых протоколов и схем взаимодействия.

Как правило, для этих целей не требуются ни сверхминиатюрность, ни высокая мощность, ни рекордная дальность — важны простота, надёжность и доступность. Именно эти принципы мы заложили в основу при создании этой линейки устройств.

Мы сознательно не ограничиваем список самих «кубиков», поскольку он изначально задуман как пополняемый. Он будет расширяться в зависимости от сценариев применения — например, при сборке антенной решётки или приёмопередатчика для измерения наклонной дальности.

<div style="page-break-after: always;"></div>

## 1. A<sup>3</sup>T и A<sup>3</sup>R 
Это импульсный одноканальный (одночастотный) передатчик и одночастотный приёмник.

### Передатчик A<sup>3</sup>T
Передатчик [A³T](A3T_Datasheet_ru.md) излучает импульсы фиксированной частоты и длительности при изменении состояния на своём цифровом входе, которым управляет пользователь.

### Приёмник A<sup>3</sup>R
Приёмник [A³R](A3R_Datasheet_ru.md) может улавливать эти импульсы и передавать информацию пользователю, изменяя состояние своего цифрового выхода.

### Особенности работы
Эти два устройства спроектированы таким образом, что могут объединяться в стек и использовать общую приёмо-передающую антенну, например, [RT-1.332820-1](https://docs.unavlab.com/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.html). В такой конфигурации получается приёмо-передатчик.

Если выход приёмника подключить ко входу передатчика, получится маяк-ответчик: принятый сигнал сразу же передаётся на вход передатчика, который излучает ответный гидроакустический сигнал. Вся связка работает по принципу "эха". Такая схема позволяет измерять, например, двойное время распространения сигнала между запрашивающим устройством и маяком-ответчиком, а следовательно, и наклонную дальность.

### Возможности масштабирования
Разъёмы, смонтированные по длинным краям плат, образуют шину, позволяющую объединить один передатчик и до 12 приёмников. При этом выходы всех приёмников будут доступны на свободном разъёме.

Таким образом можно строить и изучать различные конфигурации антенных решёток. Если 12-элементной антенной решётки недостаточно, можно использовать любое количество стеков, в каждом из которых может быть до 12 модулей [A³R](A3R_Datasheet_ru.md).

Для удобного объединения до 24 приёмников существует специальная кросс-плата [A³R-CB2](). Естественно, можно использовать любое количество таких плат.

### 1.1. О гидроакустических антеннах

Для работы с модулями **A³S** доступны антенны двух типов:
1. **Приёмо-передающие** - совместимы как с модулями [A³R](A3R_Datasheet_ru.md), так и с [A³T](A3T_Datasheet_ru.md)
2. **Приёмные** - предназначены исключительно для работы с модулями [A³R](A3R_Datasheet_ru.md)

#### Особенности выбора антенн
При использовании устройства только в режиме приёма рекомендуется выбирать приёмные антенны, так как они:
- имеют более низкую стоимость
- отличаются меньшими габаритами и массой

#### Специализированные приёмные антенны
Антенны серии [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru):
- разработаны специально для модулей A³R
- оснащены специальными креплениями
- оптимальны для построения антенных решёток при многоканальном приёме

| ![image](https://github.com/user-attachments/assets/850006dd-7430-472e-9dc8-82bf3dfe48e2) |
| :---: |
| _Антенны сделаны так, чтобы их легко можно было объединить друг с другом_ |

#### Приёмо-передающие антенны
Лаборатория подводной связи и навигации предлагает несколько моделей:

| Модель | Характеристики |
|--------|----------------|
| [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.html) | Наиболее доступное и компактное решение |
| [RT-2.332820-1](/documentation/RU/Transducers/RT_2_332820_1_Specification_ru.html) | Свешиваемая антенна для надводного оборудования (2 пьезоэлемента) |
| [RT-1.524525-1](/documentation/RU/Transducers/RT-1.524525-1_specification_ru.html) | Модель с повышенной чувствительностью |

#### Правила эксплуатации
1. **Механическая защита**:
   - Избегайте ударных нагрузок
   - Не допускайте неравномерного нагружения
   - Антенны с крепёжным пазом должны фиксироваться только за него
   - Запрещается перекрывать рабочую поверхность антенны

2. **Электрическая безопасность**:
   - Перед подключением снимайте возможный заряд (закорачивайте выводы)

3. **Уход и обслуживание**:
   - Не используйте агрессивные растворители (ацетон, изопропанол)
   - Особенно осторожно обращайтесь с полиуретановыми покрытиями

При соблюдении этих правил антенны демонстрируют долговечность и простоту в обслуживании.

### 1.2. Проект 1 - Передаем и принимаем
Самый простой сценарий, в котором задействованы один приёмник и один передатчик.

#### 1.2.1. Требуемый набор оборудования

| № | Наименование | Количество | Примечание |
|---|--------------|------------|------------|
| 1 | Модуль [A³R](A3R_Datasheet_ru.md) | 1 | |
| 2 | Модуль [A³T](A3T_Datasheet_ru.md) | 1 | |
| 3 | Антенна приёмная [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru) | 1 | |
| 4 | Антенна приёмо-передающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru) | 1 | |
| 5 | Плата с микроконтроллером (например, Arduino Nano) | 2 | Можно заменить кнопкой для инициации передачи |
| 6 | Провода Dupont Female-Female или Male-Female, 25+ см | 4 | |

#### Подключение антенн
1. Подключите приёмную антенну [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru) к модулю [A³R](A3R_Datasheet_ru.md):

| ![image](https://github.com/user-attachments/assets/bf67aad3-81d2-4186-aa74-c13dac7334d2) |
| :---: |
| _Подключение приемной антенны_ |

2. Подключите приёмо-передающую антенну [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru) к модулю [A³T](A3T_Datasheet_ru.md):

| ![image](https://github.com/user-attachments/assets/899591f9-cf9d-46a4-bc6c-e9853faeea05) |
| :---: |
| _Подключение приемопередающей антенны_ |

#### 1.2.2. Настройка передатчика

##### Принцип работы:
- Инициация передачи осуществляется изменением логического уровня на пине 4 (разъём XS2)
- Необходимо перевести пин из высокого состояния (HIGH) в низкое (LOW)
- Для этого соедините пин 4 с любым нечётным пином GND на том же разъёме

##### Схема подключения к Arduino Nano:

| Контакт на XS2 | Контакт на Arduino Nano |
|----------------|-------------------------|
| 1 (GND) | GND |
| 4 (Инициация передачи) | 10 (D10) |

##### Скетч для передачи (1 импульс в секунду):

```c
#define TX_PIN 10      // Пин инициации передачи
#define LED_PIN 13     // Индикаторный светодиод

void setup() {
  pinMode(TX_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(TX_PIN, HIGH); // Исходное состояние
}

void loop() {
  digitalWrite(TX_PIN, LOW);  // Начало передачи
  digitalWrite(LED_PIN, HIGH);
  delay(10);                 // Длительность импульса 10 мс
  
  digitalWrite(TX_PIN, HIGH); // Окончание передачи
  digitalWrite(LED_PIN, LOW);
  delay(990);                // Общий период 1 секунда
}
```

*Примечание: минимальный интервал между передачами - 40 мс*

#### 1.2.3. Настройка приёмника

##### Принцип работы:
- При обнаружении сигнала модуль переводит пин 1 (XS3) в состояние LOW на 2 мс
- Для детектирования можно использовать Arduino или осциллограф

##### Схема подключения к Arduino Nano:

| Контакт на XS3 | Контакт на Arduino Nano |
|----------------|-------------------------|
| 2 (GND) | GND |
| 1 (Строб приёма) | 2 (D2) |

##### Скетч для приёма:

```c
#define RX_PIN 2       // Пин детектирования приёма
#define LED_PIN 13     // Индикаторный светодиод

void setup() {
  pinMode(RX_PIN, INPUT);
  pinMode(LED_PIN, OUTPUT);
  attachInterrupt(digitalPinToInterrupt(RX_PIN), rxDetected, FALLING);
}

void rxDetected() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);         // Светодиод горит 100 мс при приёме
  digitalWrite(LED_PIN, LOW);
}

void loop() {
  // Основной цикл не требуется
}
```

#### 1.2.4. Тестирование системы

1. **На воздухе**:
   - Разместите антенны на расстоянии 10-15 см друг от друга
   - При успешной передаче светодиоды на обеих платах Arduino будут синхронно мигать

2. **В водной среде**:
   - Обеспечьте заглубление антенн не менее 1 метра от поверхности
   - Избегайте пузырей воздуха возле рабочих поверхностей антенн

| ![image](https://github.com/user-attachments/assets/76dd271a-f87e-45c2-bbad-dad94bc4ccd2) |
| :---: |
| _Лабораторная установка_ |

### 1.3. Кратко о многолучевости и защитных интервалах

Многолучевость и методы борьбы с ней представляют собой обширную область исследований. В данном разделе мы рассмотрим лишь основные принципы.

#### 1.3.1. Суть явления многолучевости

Явление многолучевости можно сравнить с акустическим эхом. Звуковой сигнал от источника распространяется сферическим фронтом, при этом:

1. **Прямой луч** - кратчайший путь от источника к приёмнику
2. **Отражённые лучи** - сигналы, отразившиеся от:
   - Дна водоёма
   - Поверхности воды
   - Подводных объектов
3. **Преломлённые лучи** - сигналы, изменившие направление из-за:
   - Неоднородностей водной среды
   - Изменения скорости звука на разных глубинах

#### 1.3.2. Проблемы, вызванные многолучевостью

1. **Ошибки измерения**:
   - Ложное определение наклонной дальности

2. **Эффект "эхо-петли"**:
   - В системах маяков-ответчиков возможно возникновение бесконечного цикла "запрос-ответ"
   - Особенно критично при использовании одной частоты для передачи и приёма

#### 1.3.3. Методы борьбы (на примере ACubes)

Для простых сигнальных систем наиболее эффективным решением является **защитный интервал**:

| Параметр | Описание |
|----------|----------|
| Принцип работы | После детектирования сигнала приёмник временно прекращает обработку входящих сигналов |
| Длительность | Определяется экспериментально для конкретных условий |
| Факторы влияния | Глубина, рельеф дна, наличие объектов, свойства водной среды |

**Рекомендации по настройке:**
1. Начинайте с интервала 50-100 мс для небольших акваторий
2. Постепенно увеличивайте интервал до исчезновения ложных срабатываний
3. Для точных измерений может потребоваться калибровка статической ошибки

*Примечание: В профессиональных системах используются более сложные методы (разнесённые частоты, кодирование сигналов, адаптивные алгоритмы), но они выходят за рамки данного руководства.*

### 1.4. Проект 2 - Собираем приемопередатчик и измеряем наклонную дальность

В ходе данной работы мы соберем два приемопередатчика, один из которых будет выполнять функцию маяка-ответчика, а другой сможет излучать запросный сигнал, ожидать ответный и по времени распространения сигнала и скорости звука определять наклонную дальность между абонентами.

#### 1.4.1. Требуемый набор оборудования

| №    | Наименование | Количество | Примечание |
| :--- | :--- | :--- | :--- |
| 1    | Модуль [A<sup>3</sup>R](A3R_Datasheet_ru.md) | 2 |  |
| 2    | Модуль [A<sup>3</sup>T](A3T_Datasheet_ru.md) | 2 |  |
| 3    | Антенна приемопередающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru) | 2 |  |
| 4    | Любая плата с МК, например, Arduino Nano | 2 |  |
| 5    | LCD-экран, например MT-204S | 1 | Для отображения измеренного времени и дальности, но можно выводить и в COM-порт |
| 6    | Провода Dupont Female-Female или Male-Female, 25+ см | 15 | |

На самом деле данный сценарий содержит как минимум два разных подсценария:  
**первый** подразумевает установку перемычки **P0** на маяке-ответчике, таким образом, чтобы выход приемника был соединен со входом передатчика. И маяк-ответчик в этом случае будет излучать ответный сигнал с нулевой задержкой. Казалось бы, схема наиболее удобная и максимально простая, но такой подход накладывает определенные ограничения. Дело в том, что у приемных модулей есть т.н. защитный интервал, который определяет, через какое время после приема возможен следующий прием. В свою очередь это означает, что у такой системы будет некоторая минимальная дальность, расстояние меньше которой измерить не получится - в момент прихода ответного сигнала с расстояния, меньше минимального, приемник будет ожидать завершения защитного интервала и будет невосприимчив.

Во **втором** подсценарии мы вводим фиксированную задержку между приемом запросного сигнала и излучением ответа. Значение этой задержки известно на запрашивающем устройстве и может быть легко учтено. Такая схема хоть и сложнее, но позволяет измерять расстояния почти до нулевого. Для формирования этой задержки удобнее всего воспользоваться каким-нибудь МК, например, той же Arduino.

Итак, начнем с запрашивающего устройства. Опять же, мы подготовили два варианта разной сложности - с использованием экрана и без - с передачей необходимой информации по UART.

#### 1.4.2. Запрашивающее устройство
Сначала соберем "бутерброд" из модулей A<sup>3</sup>R и A<sup>3</sup>T. Зададим адрес приемника на шине, установив джампер P1. Это сделано для того, чтобы все подключение к плате Arduino было на разъеме XS2. Оплетку и минус антенны спаиваем вместе. Платы приемника и передатчика соединяем перемычками из отрезков проводов через разъемы XS1.

| ![image](https://github.com/user-attachments/assets/c9a55a56-d37e-4aa6-8229-81f800377083) |
| :---: |
| _Подключение общей антенны к модулям приемника и передатчика_ |

Далее, подключаем сборку кубиков к плате Arduino. Для этого потребуется 4 провода папа-мама.

| ![image](https://github.com/user-attachments/assets/af9ca034-c4bb-451c-ab49-99c504a420cf) |
| :---: |
| _Подключение "бутерброда" к плате Arduino Nano_ |

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 2 / Строб при начале передачи | 3 / INT1 |
| 4 / Инициация передачи импульса | 10 |
| 6 / Строб приемника №1 | 2 / INT0 |

Если вы планируете использовать LCD-экран МЭЛТ МТ-20S4S или совместимый, то необходимо соединить пины следующим образом:

| Номер контакта на экране | Номер/Наименование контакта на Arduino Nano|
| :--- | :--- |
| 1 | GND |
| 2 | 5V |
| 4 | 8 (D8) |
| 5 | 9 (D9) |
| 10 | 4 (D4) |
| 11 | 5 (D5) |
| 12 | 6 (D6) |
| 13 | 7 (D7) |

Кроме того, необходимо на плате экрана соединить контакты 1-5 и 2-18, а также контакты 2-3 между собой. Сопротивление между контактами 2-3 задает контрастность экрана, и в некоторых случаях простого их замыкания может оказаться недостаточно. 

Ниже представлен скетч для управляющей платы Arduino:

##### 1.4.2.1. Скетч - Инициирует передачу и измеряет время между запросом и ответом
Если использование экрана не планируется, необходимо закомментировать строчку `#define USE_LCD`. Скорость звука задана константой 1500.0, для более точного значения предлагаем обратиться к нашему онлайн-калькулятору скорости звука в воде: [Толковый калькулятор скорости звука в воде](https://docs.unavlab.com/online_utils/proper_speed_of_sound_calculator.html)

```с
#define USE_LCD

#ifdef USE_LCD
#include "LiquidCrystal.h"
LiquidCrystal lcd(8, 9, 4, 5, 6, 7); // RS, E, D4-D7
#define X_MAX              (20) // Число символов на строчку экрана
#define MSG_LINE           (3)  // Номер строки для сообщения
#define W_LINE             (0)  // Номер стоки для отображения прогресса
#endif

// Пин-назначения
#define TX_CONTROL_PIN     10   // Пин управления передатчиком (активный HIGH)
#define TX_STROBE_PIN      3    // Пин строба передатчика (ожидаем FALLING edge)
#define RX_STROBE_PIN      2    // Пин строба приемника (ожидаем FALLING edge)

// Параметры системы
#define ANSWER_DELAY_MS    500    // Фиксированная задержка ответа маяка [мс]
#define SOS_MPS            1500   // Скорость звука в воде [м/с]
#define MAX_DISTANCE_M     500    // Максимальная измеряемая дальность [м]
#define PULSE_WIDTH_MS     10     // Длительность управляющего импульса [мс]

#define PAUSE_MS           (1000) // Пауза между измерениями
#define TIMEOUT            (2 * 1000000L * MAX_DISTANCE_M / SOS_MPS + ANSWER_DELAY_MS * 1000L)

#ifdef USE_LCD
#define TKS_PER_CHAR       ((TIMEOUT - ANSWER_DELAY_MS * 1000L) / X_MAX)
#endif


// Глобальные переменные
volatile uint32_t tor = 0;  // Время излучения сигнала
volatile uint32_t toa = 0;   // Время приема ответного сигнала
volatile bool rx_strobe = false; // Флаг получения строба

// Обработчик прерывания по стробу передатчика
void txStrobeISR() {
  tor = micros();
}

// Обработчик прерывания по стробу приемника
void rxStrobeISR() {
  toa = micros();
  rx_strobe = true;
}

void setup() {
  
#ifdef USE_LCD
  lcd.begin(20, 4);
  lcd.clear();
  lcd.print(F("Starting..."));  
#endif

  Serial.begin(9600);
  Serial.println(F("Starting..."));
  
  // Настройка пинов
  pinMode(TX_CONTROL_PIN, OUTPUT);
  digitalWrite(TX_CONTROL_PIN, HIGH);
 
  pinMode(TX_STROBE_PIN, INPUT);
  pinMode(RX_STROBE_PIN, INPUT);

  // Настройка прерываний
  attachInterrupt(digitalPinToInterrupt(TX_STROBE_PIN), txStrobeISR, FALLING);
  attachInterrupt(digitalPinToInterrupt(RX_STROBE_PIN), rxStrobeISR, FALLING);

  delay(1000);
}

void loop() {

#ifdef USE_LCD
  lcd.setCursor(0, W_LINE);
  lcd.print("                    ");
#endif

  // 0. Сброс
  tor = 0;

  // 1. Инициируем передачу
  digitalWrite(TX_CONTROL_PIN, LOW);
  
  // 2. Ждем строб передатчика (прерывание установит tor)
  while (tor == 0) {
    // Ожидание...
  }

  // 3. Возвращаем состояние пина, управляющего передачей
  digitalWrite(TX_CONTROL_PIN, HIGH);
  
  // 4. В течение фиксированной задержки ответа не обрабатываем приемник
  delay(ANSWER_DELAY_MS);

  toa = 0;
  rx_strobe = false;

  // 5. Ждем строб приемника с таймаутом
#ifdef USE_LCD
  int c_idx = 0;
  uint32_t tks = micros();
#endif

  while (!rx_strobe && (micros() - tor < TIMEOUT)) {
    // Ожидание...

#ifdef USE_LCD
    
    if ((micros() - tks) >= TKS_PER_CHAR) {
      
      lcd.setCursor(c_idx, W_LINE);
      lcd.print(")");

      if (c_idx < X_MAX) c_idx++;
      tks = micros();
    }
    
#endif
  }
  
  // 6. Если сигнал получен - вычисляем дальность
  if (rx_strobe) {
    // Корректно обрабатываем переполнение micros()
    uint32_t tof;
    if (toa > tor) {
      tof = toa - tor;
    } else {
      tof = (0xFFFFFFFF - tor) + toa;
    }
    
    // Вычитаем фиксированную задержку маяка и делим на 2 (туда и обратно)
    tof = (tof - ANSWER_DELAY_MS * 1000L) / 2;
    
    // Рассчитываем дальность
    float srn = tof * 1e-6 * SOS_MPS;
    
#ifdef USE_LCD
    lcd.setCursor(0, MSG_LINE);
    lcd.print("                    ");
    lcd.setCursor(0, MSG_LINE);
    lcd.print(srn, 1);    
    lcd.print(" m");
#endif

    Serial.println(srn, 1);

  } else {

#ifdef USE_LCD
    lcd.setCursor(0, MSG_LINE);
    lcd.print("      TIMEOUT       ");
#endif

    Serial.println("TIMEOUT");
  }
  
  // Пауза между измерениями
  delay(1000);
}
```

#### 1.4.3. Маяк-ответчик. Вариант 1 - без Arduino

Скажем сразу: этот вариант практически никогда не используется на практике из-за опасности попадания в цикл, когда маяк будет "самозапрашиваться" собственным ответным сигналом. 

Здесь нам необходимо собрать такой же "бутерброд", как и для запрашивающего устройства, с тем лишь отличием, что мы устанавливаем джампер **P0**, который замыкает выход приемника и вход передатчика. Строб от приемника при получении сигнала станет стробом, инициирующим передачу. Также не забудем установить джампер для задания адреса приемника на шине - это позволит вывести его на разъем XS2.

| ![image](https://github.com/user-attachments/assets/3fc329de-5cd5-4d8a-b8c5-af15bb9d1237) |
| :---: |
| _Джампер P0 соединяет выход приемника и вход передатчика_ |

Антенну подключаем таким же образом, как и для запрашивающего устройства: оплетка и минус спаяны, перемычками соединены разъемы XS1 приемника и передатчика. 
Отметим, что питание и в случае запрашивающего устройства, и в случае маяка-ответчика необходимо подавать на передающий модуль, чтобы избежать прохождения существенных токов по шине в момент излучения.

#### 1.4.4. Маяк-ответчик. Вариант 2 - с Arduino и фиксированной задержкой
В этом случае в скетче для Arduino запрашивающего устройства необходимо задать какое-то ненулевое значение `ANSWER_DELAY_MS`. И у платы приемника, и у платы передатчика длительность защитного интервала составляет 40 мсек. Соответственно, выбираемая длительность фиксированной задержки должна быть больше этого значения. В нашем примере мы установили значение 500 мс, что подойдет для большинства небольших акваторий с длительным "хвостом" отражений.

Кроме изменения значения `ANSWER_DELAY_MS` в скетче запрашивающего устройства не потребуется никаких изменений. А к маяку-ответчику теперь необходимо убрать джампер **P0** и подключить вторую плату Arduino Nano, согласно следующей таблице:

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 4 / Инициация передачи импульса | 10 |
| 6 / Строб приемника №1 | 2 / INT0 |

Вот так может выглядеть незамысловатый скетч, который ожидает приема сигнала, выдерживает паузу и излучает ответный сигнал:

##### 1.4.4.1. Скетч - Фиксированная задержка ответа
  
```с
#define A3R_STATE_PIN     (2)
#define A3T_TX_ENGAGE_PIN (10)
#define LED_PIN           (13)

#define ANSWER_DELAY_MS    (500L) // Фиксированная задержка ответа на ответчике, [мс]
#define DEAD_TIME_MS       (500L) // Защитный интервал после излучения

#define TX_STROBE_DURATION_MS  (10L)

void setup() {
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);

  pinMode(A3R_STATE_PIN, INPUT_PULLUP);
}

void loop() {
  if (digitalRead(A3R_STATE_PIN) == LOW) {
    delay(ANSWER_DELAY_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, LOW);
    digitalWrite(LED_PIN, HIGH);
    delay(TX_STROBE_DURATION_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
    delay(DEAD_TIME_MS);
    digitalWrite(LED_PIN, LOW);    
  }
}
```

#### 1.4.5. Эксперименты

##### 1.4.5.1. На столе
При работе с пьезокерамическими антеннами всегда нужно иметь в виду, что питаются они напряжением, как правило от десятков до сотен вольт. Частоты при этом обычно килогерцы и десятки килогерц. Такое сочетание может привести к тому, что на столе или даже более общо - на воздухе, гидроакустические системы могут вполне работать не акустически, а электромагнитно. В реальности же при проверках на воздухе мы имеем дело с обоими эффектами - как с акустическим, так и с электромагнитным.

Итак, для чего вообще в этом случаем может потребоваться проверка на столе, или на "столе", или даже "на столе"? Помимо того, что мы можем убедится в правильности всех соединений и в том, что в целом макет рабочий, имеет смысл определить величину статической ошибки и ее статистические параметры. Причины ее возникновения могут быть разными - и неточность хода часов, и аппаратные ограничения, ограничения, связанные с типом сигнала и методами его обработки, ну и возможно что-то где-то мы могли забыть, оценить неверно и т.д. и т.п.

К примеру, в наш тестовый макет, когда антенны лежат на воздухе и соприкаются друг с другом, т.е. когда фактическое расстояние равно нулю, выдает такие времена распространения:

| №  | T<sub>OF</sub>, c |
|---|---|
|1|0.001054|
|2|0.001182|
|3|0.001024|
|4|0.001052|
|5|0.001148|
|6|0.001174|
|7|0.000966|
|8|0.001154|
|9|0.001004|
|10|0.001044|
|11|0.001282|
|12|0.001170|

Среднее значение времени распространения по 150 измерениям равно **0.001096** с, что эквивалентно расстоянию **1.64** м при скорости звука 1500 м/с. Диапазон изменения величины T<sub>OF</sub> составляет от 0.000886 до 0.001308 с, или от 1.33 до 1.96 м соответственно.

Интересно выглядит распределение величины статической ошибки - это очень похоже на т.н. Гауссову сместь (Gaussian Mixture), т.е. смесь нормальных (Гауссовых) распределений. Мультимодальность может говорить о наличии нескольких сценариев, по которым происходит процесс.

| ![image](https://github.com/user-attachments/assets/e5c24575-9e79-4ffc-ba5a-975b0160dac2) |
| :---: |
| _Мультимодальность в распределении величины статической ошибки_ |

> ДЛЯ САМОСТОЯТЕЛЬНОЙ РАБОТЫ:
> Определить и устранить причины этой статической ошибки - интересная и увлекательная задача, и мы не можем лишить читателя удовольствия сделать это самостоятельно.

Мы же, для упрощения учтем измеренную статическую ошибку, путем вычитания ее среднего значения: введем `#define MAGIC_STATIC_S    (0.001096253)`, и будем вычитать это значение при расчете наклонной дальности:

```c
    float srn = ((tof * 1e-6) - MAGIC_STATIC_S) * SOS_MPS;
```

Подытожим: в результате экспериментов "на столе" мы:
 - удостоверились в работоспособности системы;
 - выявили наличие статической ошибки и даже немного проанализировали распределение ее величины;
 - скомпенсировали статическую ошибку самым простым способом - вычитанием.

Теперь можно переходить к водным экспериментам.

##### 1.4.5.2. В тазу

После отладки макета на столе, можно попробовать любую емкость с водой или водоем - начать можно хоть с пластикового ведра - главное, чтобы туда можно было налить воды и разместить две антенны.

Вот, к примеру, вариант "лабораторной установки". Антенны в нем расположены на расстоянии 40 см друг от друга. 

| ![image](https://github.com/user-attachments/assets/7755d3fe-a204-4de5-9fc4-3b5e7d4adb9b) |
| :---: |
| _"Лабораторная установка"_ |

Распределение измеренной дальности имеет уже несколько иной вид:

| ![image](https://github.com/user-attachments/assets/f5c483a0-cf5e-4b02-9d85-a20963b448d6) |
| :---: |
| _Распределение измеренного времени распространения_ |

Размер выборки не позволяет сделать однозначные выводы, но здесь есть намек на нормальное распределение. Данную гипотезу, увеличив размер выборки, мы предлагаем проветить пользователям самостоятельно.
И если эта гипотеза подтвердится, в несколько ином свете выгладит мультимодальность в распределении, полученном по измерениям на воздухе. 

Если перейти от времени к дальности, то для данного эксперимента получается диапазон от, фактически, нуля: -0.08 м до 2.07 м. Среднее значение и мода 0.58 м и 0.52 м соответственно.
Это некоторым образом отличается от фактического расстояния в 0.4 м между антеннами, но в таких условиях малого объема не стоит ожидать высокой точности и повторяемости результата.

Подытожим: 
- эксперимент в малом объеме имеет право на существование и даже позволяет сделать грубые количественные оценки.

##### 1.4.5.3. Плавательный бассейн

Даже в небольшом плавательном бассейне объемом ~100 м<sup>3</sup> уже появляется возможность провести количественные оценки макета оборудования более тщательно.

| ![image](https://github.com/user-attachments/assets/48787fd3-9d36-44a1-bd74-63f6947c40aa) ![image](https://github.com/user-attachments/assets/412a6042-161b-4f3c-a7bf-ee49d5d3244f) |
| :---: |
| _Хорошая согласованность непосредственного измерения с акустическими_ |

Антенны можно разместить вдоль одной и той же стенки. Очевидно, более крупные бассейны с мягким полимерным покрытием являются более благоприятными для акустических экспериментов.
В ходе экспериментов были выполнены измерения в диапазоне от 0.8 до 8 метров через фиксированные интервалы 0.8 м - соответствующие ширине бардюрной плитки, покрывающей борт бассейна.

| ![image](https://github.com/user-attachments/assets/e8027ce3-7874-4e0c-9629-c9dac71965a0) |
| :---: |
| _Результат измерения дальности на фактическом расстоянии между антеннами 8 метров_|

Распределение измеренного времени распространения, выполненное по 150 измерениям имеет такой вид:

| ![image](https://github.com/user-attachments/assets/571e1107-8c12-44ec-963c-3c8a01af741e) |
| :---: |
| _Предположительно бимодальное распределение величины измеренного времени распространения. Размер выборки 150_ |

Снова распределение имеет мультимодальный, или даже бимодальный вид. При этом, все измерения располагаются в диапазоне от 7.8 до 8.9 м, а среднее значение 8.2 хорошо согласуется с фактическим расстоянием 8 м.

> ДЛЯ САМОСТОЯТЕЛЬНОЙ РАБОТЫ:
> Стоит отметить, что в случае мультимодального распределения не вполне корректно говорить о среднем значении всей выборки. Разобраться в этом вопросе мы также предлагаем пользователю самостоятельно.

Подытожим:
- макет хорошо себя показал даже в небольшом (~100 м<sup>3</sup>) бассейне - измерения соответствуют фактическим расстояниям, разброс по выборке составляет порядка 1 м.


##### 1.4.5.4. Водоем

Напомним, что максимальная практическая дальность кубиков [A³R](A3R_Datasheet_ru.md) и [A³T](A3T_Datasheet_ru.md) согласно спецификациям составляет 300 м. Естественно это не значит что в любых, даже самых неблагоприятных условиях оборудование позволит достичь заявленных показателей, ровно не значит это и того, что на удалении 301 м, устойчиво работающая до этого связь многовенно прекратится.

Например, при проверке на максимальную дальность, передатчик, излучающий сигнал 1 раз в секунду располагался на заякоренном плоту, а приемник постепенно удалялся от него на весельной лодке, заметные перебои в приеме начинали происходить при достижении расстояния 350-370 метров. Условия эксперимента нельзя назвать ни идеальными ни очень сложными. Водоем представляет собой затон р. Волга, длиной порядка 3 км и шириной от 400 до 200 метров в разных местах. Песчаное дно, судоходство средней интенсивности, существенное количество металлических конструкций на дне. 

На этом же водоеме проводились эксперименты с обсуждаемым макетом оборудования. Маяк-ответчик располагался на заякоренном плоту из плотного вспененного материала сначала на удалении порядка 80 метров от лодочной пристани, а потом был перемещен на расстояние 156 метров. В обоих случаях расстояние фиксировалось при помощи лазерного дальномера. 

| <img width="392" height="456" alt="image" src="https://github.com/user-attachments/assets/b6e0cfac-675d-47b5-9c78-6c2ca1135ffb" /> <img width="391" height="422" alt="image" src="https://github.com/user-attachments/assets/4342aed6-f203-4b7d-b750-91f8be2b23ff" /> |
| :---: |
| _Дальность 80 м. Хорошая согласованность непосредственного измерения с акустическими_ |

| <img width="393" height="499" alt="image" src="https://github.com/user-attachments/assets/7892fc1c-cb70-4ec2-b445-5d2ed1002eff" /> <img width="391" height="398" alt="image" src="https://github.com/user-attachments/assets/24f3f6ab-b904-4735-b621-0decf85a8260" /> |
| :---: |
| _Дальность 156 м. Хорошая согласованность непосредственного измерения с акустическими_ |

При проведении экспериментов на водоемах, полезно вести запись сигналов. Например, в обсуждаемых испытаниях гидрофон, на который велась запись, располагался в непосредственной близости от антенны запрашивающего устройства и ниже преставлены сами записи и снимки экрана, на которых представлены случайные фрагменты с одним циклом "запрос-ответ" - для дальностей 80 и 156.

> ДЛЯ САМОСТОЯТЕЛЬНОЙ РАБОТЫ: При желании, читатель может сам проанализировать записи:

[10-06-2025, Красноармейский затон, г. Волгоград. A³S наклонная дальность, 80 м](https://github.com/user-attachments/assets/8c01bb6a-d6d2-4ab9-8276-31cbac882f3e)

[10-06-2025, Красноармейский затон, г. Волгоград. A³S наклонная дальность, 156 м](https://github.com/user-attachments/assets/5a3092e3-a290-4727-81cf-9193621417a8)


| <img width="1951" height="1357" alt="image" src="https://github.com/user-attachments/assets/aac68173-1779-454e-aa46-c7b138221c94" /> |
| :---: |
| _Дальность 80 м. Фрагмент записи из положения запрашивающей системы_ |

| <img width="1955" height="1355" alt="image" src="https://github.com/user-attachments/assets/706ab1b1-e68b-4366-ab5c-3b4ba7a5e06d" /> |
| :---: |
| _Дальность 156 м. Фрагмент записи из положения запрашивающей системы_ |

Во-первых, из записи можно составить представление об акватории: наличие шумов и их распределение по частотам, длительность послезвучания и т.п., а во-вторых, проконтролировать полученные результаты. 
Согласно этим двум фрагментам, расстояния между фронтами запросного и ответного сигналов составили 610 и 711 мсек соответственно.

Если учесть фиксированную задержку ответа в 500 мсек, а остаток поделить на два - путь "туда-обратно", а еще учесть определенную в [п. 1.4.5.1.](#1451-на-столе) статическую ошибку в 1.096 мсек и скорость звука 1500 м/с, то значение наклонной дальности будут:

`((0.610-0.500) / 2 - 0.001096) * 1500 = 80.86 м`, и  
`((0.711-0.500) / 2 - 0.001096) * 1500 = 156.6 м` 

что отлично согласуется и с измерением при помощи лазерного дальномера и с тем, что отображается на экране макета.

Также примечательна дительность послезвучания, составляющая около четверти секунды:

| <img width="1074" height="1348" alt="image" src="https://github.com/user-attachments/assets/3b3d379f-6ee7-4697-bacf-fdecfad4b3ed" /> |
| :---: |
| _4-х миллисекундный сигнал "гуляет" по акватории еще 250 миллисекунд_ |

Если бы фиксированная задержка была меньше этой величины, то запрашивающее устройство вполне могло бы принять свой собственный сигнал за сигнал маяка-ответчика.

> ДЛЯ САМОСТОЯТЕЛЬНОЙ РАБОТЫ:
> Что же до статистического анализа измерений наклонной дальности, то мы предлагаем пользователю провести его самому. Будет интересно сравнить результаты экспериментов, проведенных в разных водоемах и разных условиях - погрешность, процент успешных измерений, оценить влияние скорости звука и т.п.
> Например, в ледовых условиях гораздо проще обеспечить статичное положение запрашивающего устройства и маяка-ответчика, а также более точно измерить фактическое расстояние между ними.

Подытожим:
- устройства показали работоспособность в условиях реального водоема
- проверка тремя независимыми способами: лазерным дальномером, по записи и по проверяемому макету оборудования хорошо согласуются между собой

### 1.5. Проект 3 - Гидроакустический модем

Со словом "модем" имеется определенная путаница, особенно, когда речь идет о гидроакустических модемах. Сам термин "модем" является производным от **МОДулятор** и **ДЕМодулятор**. Сейчас под этим скорее понимается устройство для передачи и приема _цифровых_ данных. Так же часто можно встретить неудачный перевод на английский - "sonar modem", что, конечно же неверно, т.к. sonar - это буквально означает "sound(sonic) navigation and ranging", что скорее относится к гидролокации, или к эхолокации.

Очевидно, что мы на основе "кубиков" будем делать простейшее устройство для приема и передачи цифровых данных. Конечно, мы сильно ограничены в плане возможностей манипуляции с сигналами: по сути все, что нам доступно - управление моментом передачи импульса. На этой возможности мы и построим свой протокол передачи.

Кодирование передаваемых данных будет осуществляться задержкой между двумя последовательными импульсами. По предыдущим экспериментам мы помним, что требуется некоторый защитный интервал, иначе приемник будет постоянно срабатывать пока в акватории не затухнут все послезвучания. В [п. 1.4.5.4.](#1454-водоем)  vы опытным путем установили, что сигнал затухает до такого уровня, что уже не детектируется приемником, в течение примерно 200-250 миллисекунд. 

Начнем со значения минимального интервала между двумя импульсами в 300 миллисекунд. Это значит, что приняв первый импульс, приемник засекает время и в течение 300 миллисекунд не анализирует состояние линии. 
К примеру, если мы хотим передавать порциями по 8 бит, то необходимо выбрать некий интрвал и разбить его на 256 значений, нулевое значение будет соответствовать минимальной задержке - 300 мс, а значение 256 - максимально возможной. После второго, "стопового" импульса так же необходимо выдержать какой-то защитный интервал и крайне желательно сделать его отличным от первого интервала. 
Далее, мы из технических характеристик модуля передатчика знаем, что длительность одного импульса составляет 4 миллисекунды, поэтому имеет смысл выбирать разницу между двумя соседними значениями больше, чем 4 мс. В нашем эксперименте мы примем это значение равным 8 мс - в два раза больше длительности импульса.

Теперь на время отвлечемся от алгоритма работы модема и проверим оборудование.

#### 1.5.1. Требуемый набор оборудования

| №    | Наименование | Количество | Примечание |
| :--- | :--- | :--- | :--- |
| 1    | Модуль [A<sup>3</sup>R](A3R_Datasheet_ru.md) | 2 |  |
| 2    | Модуль [A<sup>3</sup>T](A3T_Datasheet_ru.md) | 2 |  |
| 3    | Антенна приемопередающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru) | 2 |  |
| 4    | Любая плата с МК, например, Arduino Nano | 2 |  |
| 5    | Провода Dupont Male-Female или Female-Female, 15+ см | 6 | |

Дополнительно, как и для предыдущих опытов, потребуются источники питания для "кубиков". В качестве источника питания удобно использовать сборку 3S из Li-Ion или LiFePO4 аккумуляторов.
Также потребуются два ПК, или один ПК с возможностью подключения двух плат Arduino. 
Еще будет нужно какое-нибудь терминальное ПО, чтобы была возможностью посылать данные в последовательный порт и отображать данные, пришедшие из порта.
Например, вполне подойдет утилита 'Serial monitor' из Arduino IDE, но если предполагается использовать один и тот же ПК для подключения обоих модемов, то это будет затруднительно. 
Для работы в Windows vожно использовать нашу простенькую утилиту [uConsole](https://github.com/ucnl/uConsole/releases/download/1.0/uConsole.zip).

#### 1.5.2. Подключение
Коль скоро требуются все те же возможности, что и в предыдущих экспериментах, то подключение модема по сути идентично подключению маяка-ответчика из [п. 1.4.4.](#144-маяк-ответчик-вариант-2---с-arduino-и-фиксированной-задержкой).

Для удобства приведем эту информацию еще раз:

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 4 / Инициация передачи импульса | 10 |
| 6 / Строб приемника №1 | 2 / INT0 |

Наш экспериментальный набор выглядит таким образом:

| <img width="640" height="853" alt="image" src="https://github.com/user-attachments/assets/7b36dc8f-328f-4138-a94d-69edd4b696dd" /> |
| :---: |
| _Два гидроакустических модема_ |

#### 1.5.3. Скетч модема

Как видно по коду, скетч получается не очень сложным. Мы принимаем интервал нулевого значения равным 300 мс, защитный "постфиксный" интервал после второго импульса - 420 мс, а расстояние между двумя соседними значениями ровно в два раза больше длительности импульса - 8 мс.

```с

#define A3R_STATE_PIN          (2)
#define A3T_TX_ENGAGE_PIN      (10)
#define LED_PIN                (13)

#define TX_STROBE_DURATION_MS  (10L)

#define SS_PRE_DEAD_TIME_MS    (300L)
#define SS_POS_DEAD_TIME_MS    (420L)
#define SS_TIME_SLOTS          (256L)
#define SS_TIME_SLOT_MS        (8L)
#define SS_MAX_TIME_MS         (SS_TIME_SLOTS * SS_TIME_SLOT_MS + SS_PRE_DEAD_TIME_MS + TX_STROBE_DURATION_MS)

bool receiving = false;
uint32_t r_str_time = 0;
uint32_t r_stp_time = 0;
float r_byte = 256;

void strobe() {
  digitalWrite(A3T_TX_ENGAGE_PIN, LOW);
  digitalWrite(LED_PIN, HIGH);
  delay(TX_STROBE_DURATION_MS);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
  digitalWrite(LED_PIN, LOW);
}

void setup() {

  Serial.begin(9600);

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);

  pinMode(A3R_STATE_PIN, INPUT_PULLUP);

}

void loop() {

  while (Serial.available()) {

    receiving = false;
    
    uint8_t b = Serial.read();
    uint32_t ss_time = SS_PRE_DEAD_TIME_MS + SS_TIME_SLOT_MS * b - TX_STROBE_DURATION_MS;

    strobe();
    delay(ss_time);

    strobe();
    delay(SS_POS_DEAD_TIME_MS);
  }

  int r_state = digitalRead(A3R_STATE_PIN);
  if ((r_state == LOW) && !receiving) {

    r_str_time = millis();
    receiving = true;
    delay(SS_PRE_DEAD_TIME_MS);

    bool is_timeout = false;
    while ((digitalRead(A3R_STATE_PIN) != LOW) && (!is_timeout)) {
      is_timeout = millis() - r_str_time > SS_MAX_TIME_MS;
    }

    if (!is_timeout)
    {
      r_stp_time = millis();

      float duration_ms = r_stp_time - r_str_time - SS_PRE_DEAD_TIME_MS;
      r_byte = duration_ms / SS_TIME_SLOT_MS;

      if ((duration_ms >= 0) && (r_byte <= 255)) {
        Serial.write((uint8_t)round(r_byte));
        delay(SS_POS_DEAD_TIME_MS);
      } 
    }

    delay(10);

    receiving = false; 
  }
}

```

Работа скетча исключительно несложна: пока есть байты, пришедшие по последовательному интерфейсу, скетч выбирает их и формирует соответствующий сигнал:

1. излучается стартовый импульс
2. выдерживается пауза, складывающаяся из минимальной ("нулевой") задержки
3. задержки кодирующей значение передаваемого байта
4. затем следует стоповый импульс
5. выдерживается "постфиксная" задержка

Приемник работает так:

1. проверяется состояние строба приемника
2. если состояние активно (пин в логическом состоянии 0) - засекается момент времени по встроенным часам
3. выдерживается защитный интервал в 300 мс
4. ожидается приход второго (стопового) импульса с отслеживанием превышения интервала ожидания
5. если второй импульс приходит во время - засекается момент времени его прихода
6. значение принятого байта вычисляется как деление разности времен прихода второго и первого импульсов на 8 мс

У нас же получился такой результат на воздухе, при расстоянии порядка 70 см между антеннами:

| <img width="1169" height="864" alt="image" src="https://github.com/user-attachments/assets/90311d52-16f3-44df-a0d1-0cfce6aef984" /> |
| :---: |
| _Жрунал обмена между двумя модемами_ |

По записи легко и непринужденно можно "демодулировать" сигнал "вручную". Вот, например, запись сделанная на воздухе:

| <img width="1948" height="1426" alt="image" src="https://github.com/user-attachments/assets/e4d0ea71-b5b7-44c8-99f8-6fe8dad4025f" /> |
| :---: |
| _Жрунал обмена между двумя модемами_ |

Расстояние между фронтами импульсов по записи 686 миллисекунд. Вычитаем их них 300-миллисекундную фиксированную зержку и делим на 8: `(686 - 300) / 8 = 48.25`. Округляем 48.25 и получаем значение передаваемого байта - 48, то есть ASCII-код цифры **0**.

> ДЛЯ САМОСТОЯТЕЛЬНОЙ РАБОТЫ:  
> 1. Можно попробовать поменять различные временные значения с целью уменьшения длительности передачи, а соответственно увеличения скорости передачи данных.
> 2. Также было бы полезно вычислить и определить экспериментально получившуюся скорость передачи.
> 3. В примере выше мы получили дробное значение 48.25, что будет с приемником, если выполнять только целочисленные операции? Что будет, если полученное значение окажется не 48.25, а, скажем, 48.52?

Подытожим:
- мы выяснили, что такое гидроакустический модем и как его можно сделать даже имея самые минимальные возможности по манипуляции с сигналом
- мы сделали гидроакустический модем, передающий данные порциями по 8 бит, который кодирует значение при помощи задержки между двумя импульсами одной частоты и фиксированной длительности

### 1.6. Проект 4 - Антенная решетка: измерение угла прихода сигнала

> _Если вы не знаете, какой размер выборки вам подойдет, то можно взять число 216_  
> О. В. Верходанов, Астрофизик

Вот уши у человека - это антенная решетка, как и у других живых существ, обладающих слухом. Формально она простенькая - всего из двух элементов, но в реальности все устроено интереснее - мозг осуществляет очень сложную многоуровневую обработку, которая в том числе связана и с ощущением габаритов своего тела, силы звука, восприятием разных частот, эффектом Доплера, не говоря уже об опыте.

Но нам здесь важно даже не то что бы понять, нам важно немного прикоснуться к принципам, которые лежат в основе угломерных пеленгационных гидроакустических систем. Используя практический подход, конечно.

Мы будем делать угломерную систему на основе антенны из 4 (четырех) приемников. Конечно, в предельном случае хватило бы и двух, но, как мы уже упомянули, чтобы добиться приемлемого результата с двумя "ушами" нужен хотя бы рептильный мозг, а у нас нет никакого. Поэтому качество будем компенсировать количеством - это распространенная практика в природе, социальной жизни и технике.

Предлагаем кратко обозначить план мероприятий. Во-первых, чтобы понять, на каком приемлемом расстоянии надо расставить наши "уши" - антенны, надо определить, как сильно флуктуирует момент детектирования сигнала в разных приемниках. Коль скоро мы будем изготавливать линейный массив - ULA (uniform linear array), расстояние между приемными элементами должно быть не меньше, чем амплитуда флуктуаций, говоря простым языком, если у нас разные приемники, антенны которых лежат рядом определяют момент прихода сигнала с разностью друг относительно друга порядка 1 миллисекунды, то расстояние между элементами менее 1.5 метров делать бессмысленно.
Во-вторых, нам нужно определиться, получится ли читать состояние пинов четырех приемников при помощи Arduino Nano с достаточной скоростью и точностью или придется поискать какую-то более производительную платформу.

Теперь определимся с набором оборудования.

### 1.6.1. Требуемый набор оборудования

| №    | Наименование | Количество | Примечание |
| :--- | :--- | :--- | :--- |
| 1    | Модуль [A<sup>3</sup>R](A3R_Datasheet_ru.md) | 4 |  |
| 2    | Модуль [A<sup>3</sup>T](A3T_Datasheet_ru.md) | 1 |  |
| 3    | Антенна приемопередающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru) | 1 |  |
| 4    | Антенна приемная Антенна приёмная [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru) | 4 | |
| 5    | Любая плата с МК, например, Arduino Nano | 2 |  |
| 6    | Провода Dupont Male-Female или Female-Female, 15+ см | 8 | |

Естественно, дополнительно потребуются два источника питания, кабель для прошивки и получения данных от Arduino.

В ходе этого проекта нам предстоит сделать приемную и передающую части, причем, приемная будет ощутимо сложнее, а передающая очень простой. Передающая необходима для проверки и отладки приемной, поэтому начнем именно с нее.

#### 1.6.3. Пингер

Пожалуй, это будет самое простое устройство из тех, что мы сделаем на протяжении этого курса. Вся его задача состоит в том, чтобы раз в некоторый временной период инициировать передачу.
Соединение платы передатчика с платой Arduino Nano сделаем согласно таблице:

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 4 / Инициация передачи импульса | 10 |
| 20 / VCC | Vin |

> ОЧЕНЬ ВАЖНО! В таблице выше указано, что выход напряжения питания с платы предатчика заводится на пин Vin платы Arduino Nano - это делается **только после** того, как плата будет прошита и отключена от ПК!!! В противном случае, она скорее всего выйдет из строя!

К плате передатчика, также, не забываем подключить приемопередающую антенну. 

Простейший скетч даже не будем выносить в отдельную главу, а приведем прямо тут:

```

#define A3T_TX_ENGAGE_PIN      (10)
#define LED_PIN                (13)
#define PING_HALF_PERIOD_MS    (2000L) 
#define TX_STROBE_DURATION_MS  (10L)

void setup() {

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
}

void loop() {

    delay(PING_HALF_PERIOD_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, LOW);
    digitalWrite(LED_PIN, HIGH);
    delay(TX_STROBE_DURATION_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
    delay(PING_HALF_PERIOD_MS);    
    digitalWrite(LED_PIN, LOW);    

}

```

Его единственная задача состоит в том, чтобы через заданный промежуток времени притягивать ножку, управляющую передатчиком на 10 миллисекунд к земле, инициируя тем самым передачу сигнала.


#### 1.6.3. Приемник

Четыре платы приемника мы оъединим в стопку - сделаем то, для чего они и были предназначены. Но перед этим нужно подключить антенны и задать адреса, чтобы сигналы от разных приемников были разнесены по шине.

| <img width="640" height="853" alt="image" src="https://github.com/user-attachments/assets/8eaacc7e-516a-4180-8df2-056bf69282f8" /> |
| :---: |
| _Задание адресов приемникам при помощи установки джамперов_ |

Рекомендуем установить платы в стопку в прямом или обратном порядке: чтобы снизу был адрес 1, выше 2, 3 и приемник, с адресом 4 на самом верху - так будет проще избежать путаницы с антеннами. Антенны тоже крайне рекомендуется пронумеровать, можно повесить бирки на кабели или прямо написать на антенне номер восковым карандашом (в воде он сотрется). Ни в коем случае не стоит использовать перманетный маркер - при длительном контакте краситель может диффундировать в полимер и стереть его будет крайне затруднительно.

Далее подключаем стопку приемников к плате Arduino Nano согласно таблице:

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 6 / Строб приемника №1 | 2 |
| 8 / Строб приемника №2 | 3 |
| 10 / Строб приемника №3 | 4 |
| 12 / Строб приемника №4 | 5 |

У нас это получилось вот так:

| <img width="640" height="853" alt="image" src="https://github.com/user-attachments/assets/bfb02dac-9c5a-4650-8cd3-424ec85962d5" /> |
| :---: |
| _Стопка из четырех приемников подключена к плате Arduino Nano_ |

##### 1.6.3.1. Скетч для обработки антенной решетки

По задумке, скетч должен передавать на ПК четыре времени прихода сигнала на каждый из приемников. Важно отслеживать разные ложные срабатывания и основным критерием того, что мы принимаем наш сигнал будет тот факт, что все времена прихода находятся в некотором диапазоне, определяемом размерами нашей антенной решетки. 

```

#include "Limits.h"

#define A3R1_STATE_PIN (2)
#define A3R2_STATE_PIN (3)
#define A3R3_STATE_PIN (4)
#define A3R4_STATE_PIN (5)

#define LED_PIN (13)

const uint8_t inputPinsMasks[] = { B00100000,
                                   B00010000,
                                   B00001000,
                                   B00000100 };

const uint8_t inputPins[] = { A3R1_STATE_PIN, A3R2_STATE_PIN, A3R3_STATE_PIN, A3R4_STATE_PIN };
const int numPins = 4;

bool lastPinState[numPins];
bool pinFallen[numPins];  
unsigned long fallTime[numPins];

const unsigned long DETECTION_WINDOW = 2000;

bool is_any_pin = false;
unsigned long pin_minTime = 0;
unsigned long pin_maxTime = 0;
uint8_t fallen_pins = 0;

void checkPinTimes() {

  is_any_pin = false;
  fallen_pins = 0;

  for (int i = 0; i < numPins; i++) {
    if (pinFallen[i]) {
      fallen_pins++;

      if (!is_any_pin) {
        is_any_pin = true;
        pin_minTime = fallTime[i];
        pin_maxTime = pin_minTime;
      }
    }
  }

  if (is_any_pin) {

    for (int i = 0; i < numPins; i++) {

      if (pinFallen[i]) {
        if (fallTime[i] > pin_maxTime)
          pin_maxTime = fallTime[i];
        if (fallTime[i] < pin_minTime)
          pin_minTime = fallTime[i];
      }
    }
  }  
}

void resetAllFlags() {

  for (int i = 0; i < numPins; i++) {
    pinFallen[i] = false;
  }
}

void setup() {

  Serial.begin(9600);

  for (int i = 0; i < numPins; i++) {
    pinMode(inputPins[i], INPUT_PULLUP);

    // lastPinState[i] = digitalRead(inputPins[i]);
    lastPinState[i] = (PIND & inputPinsMasks[i]) > 0;
    pinFallen[i] = false;
    fallTime[i] = 0;
  }
}

void loop() {

  unsigned long currentTime = micros();

  uint8_t cPIND = PIND;  
  for (int i = 0; i < numPins; i++) {

    bool currentState = (cPIND & inputPinsMasks[i]) > 0;
    if (!currentState && lastPinState[i]) {
      pinFallen[i] = true;
      fallTime[i] = currentTime;
    }

    lastPinState[i] = currentState;
  }

  checkPinTimes();

  if (is_any_pin) {

    if (fallen_pins == numPins) {

      if ((pin_maxTime - pin_minTime) <= DETECTION_WINDOW) {

          /**/
          for (int i = 0; i < numPins; i++) {
            Serial.print(fallTime[i] - pin_minTime);
            Serial.print(", ");
          }
          /**/

          Serial.println();
          delay(500);
        }

      resetAllFlags();

    } else {

      if (currentTime - pin_minTime > DETECTION_WINDOW * 100) {

        resetAllFlags();
        delay(100);
      }
    }
  }
}

```

Забегая вперед, отметим, что в скетче пришлось отказаться от стандартных функций `digitalRead` и перейти к прямой работе с регистрами для ускорения. Это некоторым образом делает скетч менее гибким.

#### 1.6.4. Эксперимент по определению амплитуды разброса времени прихода

Как и говорилось ранее, прежде чем делать антенную решетку, нужно опредлить на сколько флуктуирует момент времени прихода сигнала на разные приемники. Для этого нам потребуется пол ведра воды.
В ведре мы можем расположить все приемные антенны в непосредственной близости от передающей. Так мы исключим все эффекты связанные с временем распространения и сможем оценить, насколько по-разному работают приемники.

Напомним, что нам это нужно для того, чтобы определиться с размерами антенной решетки.

Экспериментальная установка в нашем случае выглядит вот так: 

| <img width="640" height="853" alt="image" src="https://github.com/user-attachments/assets/d5ccbea9-d34e-4dfb-8015-4ae33906072f" /> |
| :---: |
| _Ведро не обязательно должно быть синим =)_ |

Итак:

- плата Arduino передатчика прошита и отключена от ПК
- плата Arduino приемника прошита и подключена к ПК
- в среде Arduino IDE открыта утилита 'Serial Monitor' или запущено любое другое терминальное приложения для получения данных с последовательного порта
- на стопку приемников подано питание
- на передатчик подано питание

Если все собрано правильно, то в окне утилиты 'Serial Monitor' мы сможем увидеть приходящие раз в 4 секунды сточки, сожержащие по 4 числа через запятую. Скетч _нормализует_ времена прихода - вычитает наименьшее из каждой группы. 
Достаточно будет набрать несколько десятков строк.

У нас получился такой набор:

| №4 | №3 | №2 | №1 |
| :--- | :--- | :--- | :--- |
| 200| 156| 200| 0 |
| 84| 40| 84| 0 |
| 0| 212| 0| 124 |
| 120| 80| 0| 164 |
| 80| 252| 40| 0 |
| 0| 80| 120| 120 |
| 80| 164| 0| 120 |
| 116| 204| 0| 116 |
| 0| 40| 84| 252 |
| 120| 380| 0| 160 |
| 84| 128| 40| 0 |
| 232| 0| 232| 232 |
| 40| 252| 160| 0 |
| 168| 212| 80| 0 |
| 324| 0| 452| 240 |
| 116| 164| 116| 0 |
| 76| 76| 248| 0 |
| 0| 80| 208| 40 |
| 40| 128| 84| 0 |
| 0| 292| 76| 76 |
| 204| 288| 204| 0 |
| 80| 204| 204| 0 |
| 84| 0| 212| 168 |
| 40| 284| 412| 0 |
| 284| 0| 240| 116 |
| 156| 280| 280| 0 |
| 40| 40| 40| 0 |
| 240| 240| 156| 0 |
| 0| 164| 208| 40 |
| 40| 0| 168| 0 |
| 0| 172| 40| 172 |
| 0| 212| 128| 80 |
| 0| 120| 120| 40 |
| 160| 0| 248| 80 |
| 116| 160| 244| 0 |
| 232| 320| 232| 0 |
| 0| 248| 204| 40 |
| 0| 324| 412| 40 |
| 80| 168| 40| 0 |
| 164| 208| 0| 0 |
| 232| 320| 276| 0 |
| 0| 252| 164| 0 |
| 120| 288| 200| 0
| 44| 212| 0| 0 |
| 0| 292| 208| 0 |
| 0| 200| 200| 120 |
| 0| 200| 200| 80 |
| 0| 40| 124| 80 |

Для наглядности нанесем эти времена на график:

| <img width="832" height="454" alt="image" src="https://github.com/user-attachments/assets/9d3528e6-8906-403b-9c01-cdcea046e202" /> |
| :---: |
| _Большая часть значений не превышает 350 мкс_ |

Из этого графика мы видим, что в основном времена прихода колеблятся относительно друг друга в пределах 300-350 микросекунд. Для скорости звука ~1500 м/с это соответствует примерно 0.5 метра.
Точность не фантастическая, но с этим вполне можно работать. 

На основании этой определенной величины мы можем выбрать расстояние между элементами в нашей антенной решетки равным 1 метр. Конечно, выборка достаточно маленькая и велика вероятность, что разброс может дойти и до 1 миллисекунды, но, во-первых, мы хотим понять принцип, а во-вторых, мы сможем увидеть эти ситуации уже при вычислении углов прихода. А сейчас нам важно не усложнять себе жизнь излишне громоздкой антенной решеткой и понять, что и при этом размере, большая часть данных может иметь достаточную точность.

#### 1.6.5. Антенная решетка

Если у вас есть возможность каким-либо простым способом развесить 4 приемные антенны через 1 метр - очень хорошо, вам почти ничего не придется делать, у нас же такой возможности нет и мы собрали такую конструкцию из водопроводных полипропиленовых труб:

| <img width="640" height="853" alt="image" src="https://github.com/user-attachments/assets/4f83bbf1-cee1-4bb4-8bc8-9d188ff52e59" /> |
| :---: |
| _Простейшая конструкция для размешения четырех приемных антенн через метр друг от друга_ |

Мы предполагали, что конструкция может располагаться непосредственно на воде (речь конечно же идет о бассейне - на водоем такое носить крайне не рекомендуется) и поэтому дополнительно добавили плавучести. Но, кстати этого можно было бы и не делать.

> Давайте прикинем плавучесть всей рамы. Для этого сначала взвесим ее: у нас получилось 1,5 кг. Теперь нужно прикинуть объем вытесняемой воды по нижней границе - вес у нас по верхней границе, объем - по нижней, если масса воды полученного объема с некоторым запасом превышает измеренный вес, то все в порядке: конструкция вполне будет держаться на воде. Вычислять будем очень просто, т.к. нам нужен минимальный объем, то мы просто посчитваем объем трубы, без учета фитингов - они увеличивают объем.  
> Итак, у нас труба диаметром 25 мм, значит площадь сечения $&pi;r^2 = 3.1415*0.00125^2=0.000490859 м^2$. Длина всей использованной трубы 8 м, умножаем одно на другое и получаем объем вытесняемой воды: $0.000490859 * 8 = 0.003926875 м^3$. Масса этого объема воды, с учетом плотности в $1000 кг/м^3$ составит 3.9 кг. А измеренный вес всей конструкции всего 1.5 кг, значит у нас есть 3.9-1.5=2.4 кг избыточной плавучести.








### 1.7. (Планируется) Проект 5 - Определение положения ответчика методом виртуальной длинной базы

#### 1.7.1. (Планируется) Требуемый набор оборудования

### 1.8. (Планируется) Проект 6 - Длиннобазисная навигационная система

#### 1.8.1. (Планируется)Требуемый набор оборудования

#### 1.8.2. (Планируется)Навигационный буй-приемник



## 2. (Планируется) A<sup>3</sup>TC и A<sup>3</sup>RC

## 3. (Планируется) A<sup>3</sup>T2 и A<sup>3</sup>R2

## 4. (Планируется)A<sup>3</sup>AM


[К содержанию](#содержание)

<div style="page-break-after: always;"></div>
