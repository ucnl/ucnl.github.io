
[Главная](/README_RU) ❯ [Наши проекты для образования](/educational_projects_ru) ❯ **ACubes: Руководство пользователя**

<div style="page-break-after: always;"></div>

| ![logo](/documentation/sm_logo.png) | ![image](https://github.com/user-attachments/assets/f9be473c-561b-4536-8c0b-7ab44e6598aa) |
| :---: | ---: |
| [www.unavlab.com](https://www.unavlab.com/) <br/> [support@unavlab.com](mailto:support@unavlab.com) | **A<sup>3</sup>S** **ACoubes** <br/> Руководство пользователя |


# Семейство устройств **A<sup>3</sup>S** <br/> Руководство пользователя

<div style="page-break-after: always;"></div>

## Содержание

- [0. Для кого и зачем эта коробка с кубиками?]()
- [1. A<sup>3</sup>T и A<sup>3</sup>R]()
  - [1.1. О гидроакустических антеннах]()
  - [1.2. Сценарий №1 - Передаем и принемаем]()
    - [1.2.1. Требуемый набор оборудования]()
    - [1.2.2. Скетч №1 - Инициация передачи 1 раз в секунду]()
    - [1.2.3. Скетч №2 - Зажигаем светодиод по факту приема акустического сигнала]()
  - [1.3. Кратко о многолучевости и защитных интервалах]()
  - [1.4. Сценарий №2 - Собираем приемопередатчик и измеряем наклонную дальность]()
    - [1.4.1. Требуемый набор оборудования]()
    - [1.4.2. Запрашивающее устройство]()
      - [1.4.2.1. Скетч #3 - Инициирует передачу и измеряет время между запросом и ответом]()
    - [1.4.3. Маяк-ответчик. Вариант №1 - без Arduino]()
    - [1.4.4. Маяк-ответчик. Вариант №2 - с Arduino и фиксированной задержкой]()
      - [1.4.4.1. Скетч #4 - Фиксированная задержка ответа]()


<div style="page-break-after: always;"></div>

## 0. Для кого и зачем эта коробка с кубиками?
В первую очередь **ACubes** задумывался для применения в сфере образования и подготовки инженерных кадров. 

**A<sup>3</sup>S** или **ACubes** или "Акустические кубики" - это конструктор, набор из элементарных функциональных элементов, на основе которых можно создавать макеты практически любых типов гидроакустических навигационных систем и систем связи:

- простейшие системы передачи цифровой информации - гидроакустические модемы
- системы для беспроводной передачи голоса
- фазированные антенные решетки, а на их основе и ультракороткобазисные (USBL) навигационные системы с маяками-ответчиками
- длиннобазисные, короткобазисные, а также системы с синтезированной измерительной базой
- системы телеуправления
- системы сетевого мониторинга

"Кубики" берут на себя вопросы связанные с преобразованием цифрового сигнала в гидроакустический и обратно, позволяя пользователю сконцентрироваться на решении своих прикладных задач - разработке оригинальных навигационных алгоритмов или алгоритмов помехоустойчивого кодирования, сетевых протоколов и схем взаимодействия. Как правило, для этих целей не требуются ни сверхминиатюрность, ни высокая мощность, ни рекордная дальность - требуется _простота, надежность и доступность_ - это мы и постарались заложить в основу, при создании этой линейки устройств.

Мы осознанно не ограничиваем список самих "кубиков", потому что он изначально задуман, как _пополняемый_. Он будет строиться из разных сценариев применения, например, сборка антенной решетки или приемо-передатчика для измерения наклонной дальности. 

## 1. A<sup>3</sup>T и A<sup>3</sup>R 
Это импульсный одноканальный (одночастотный) передатчик и одночастотный приемник. 

Передатчик [A<sup>3</sup>T](A3T_Datasheet_ru.md) излучает импульсы фиксированной частоты и длительности при изменении состояния на своем цифровой входе, которым управляет пользователь. 
Приемник [A<sup>3</sup>R](A3R_Datasheet_ru.md) может улавливать эти импульсы и передавать пользователю, изменяя состояние своего цифрового выхода.

Эти два устройства спроектированы таким образом, что могут объединяться в стек и использовать общую приемопередающую антенну, например, [RT-1.332820-1](https://docs.unavlab.com/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.html). В таком виде получится приемопередатчик. 

Если выход приемника подключить ко входу передатчика, получится маяк-ответчик - принятый сигнал сразу же передается на вход передатчика, который излучает ответный гидроакустический сигнал и вся связка работает как "эхо". При помощи данной схема можно измерять, например, двойное время распространения между запрашивающим и маяком-ответчиком, а следовательно и наклонную дальность.

Разъемы, смонтированные по длинным краям плат являются, по сути, шиной, на которую можно объединить один передатчик и до 12 приемников. При этом выходы всех приемников будут доступны на свободном разъеме. 

Таким образом можно строить и изучать разные конфигурации антенных решеток. В случае, если 12-ти элементной антненной решетки мало, ничто не запрещает использовать сколько угодно стеков, в каждом из которых может быть до 12 модулей A<sup>3</sup>R. 

Для того, чтобы удобно объединить до 24 приемников есть специальная кросс-плата A<sup>3</sup>R-CB2. И конечно, никто не запрещает использование любого числа таких плат.

### 1.1. О гидроакустических антеннах
Для использования с модулями **A<sup>3</sup>S** могут использоваться антенны двух типов - приемопередающие, которые можно использовать как с модулями [A<sup>3</sup>R](A3R_Datasheet_ru.md), так и с модулями [A<sup>3</sup>T](A3T_Datasheet_ru.md), так и чисто приемные, подходящие для работы только с модулями [A<sup>3</sup>R](A3R_Datasheet_ru.md).

Зачастую, если от конкретного устройства требуется только приемная функция, целесообразно использовать приемную антенну, т.к. она, во-первых, дешевле, а во-вторых, меньше по габаритам и массе.

Приемные антенны [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru.md) специально разработаны для использования с модулями [A<sup>3</sup>R](A3R_Datasheet_ru.md) и имеют специальные крепления для построения антенных решеток, при многоканальном приеме.

| ![image](https://github.com/user-attachments/assets/850006dd-7430-472e-9dc8-82bf3dfe48e2) |
| :---: |
| |

В качестве приемопередающей антенны (или просто в качестве передающей) могут быть использованы все приемопередающие антенны, производимые лабораторией подводной связи и навигации:

- [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.md) - самое доступное и малогарабритное решение
- [RT-2.332820-1](/documentation/RU/Transducers/RT_2_332820_1_Specification_ru.html) - свешиваемая антенна для надводного оборудования на основе двух пьезоэлементов
- [RT-1.524525-1](/documentation/RU/Transducers/RT-1.524525-1_specification_ru.html) - антенна с увеличенной чувствительностью

Общие правила применения гидроакустических антенн достаточно просты:
- к антеннам не следует прилагать ударных нагрузок или неравномерного нагружения
- при креплении, антенны, имеющие крепежный паз должны крепиться только за него
- не допускается механическое перекрытие рабочей поверхности антенны
- при подключении к электронным модулям желательно снять возможный заряд с антенны, закоротив ее выводы

Не стоит использовать агрессивные растворители типа изопропанола или ацетона для очистки поверхностей антенн или кабелей, особенно тех, покрытие которых выполнено из полиуретана.
В остальном, антенны достаточно просты в обслуживании и долговечны.

### 1.2. Сценарий №1 - Передаем и принемаем 
Самый простой сценарий, в которм задействованы один приемник и один передатчик. 

#### 1.2.1. Требуемый набор оборудования

| №    | Наименование | Количество | Примечание |
| :--- | :--- | :--- | :--- |
| 1    | Модуль [A<sup>3</sup>R](A3R_Datasheet_ru.md) | 1 |  |
| 2    | Модуль [A<sup>3</sup>T](A3T_Datasheet_ru.md) | 1 |  |
| 3    | Антенна приемная [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru.md) | 1 |  |
| 4    | Антенна приемопередающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.md) | 1 |  |
| 5    | Любая плата с МК, например, Arduino Nano | 2 | Плату для инициации передачи можно заменить кнопкой |
| 6    | Провода Dupont Female-Female или Male-Female, 25+ см | 4 | |

Сначала необходимо подключить гидроакустические антенны к модулям. 
Приемную [R-1.d3505-1](/documentation/RU/Transducers/R_1.d3505_1_Specification_ru.md) к [A<sup>3</sup>R](A3R_Datasheet_ru.md):

| ![image](https://github.com/user-attachments/assets/7cedae37-16d1-4a18-8254-a32e16ff09b4) |
| :---: |
| |

и приемопередающую [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.md) к [A<sup>3</sup>T](A3T_Datasheet_ru.md):

| ![image](https://github.com/user-attachments/assets/c3f2d99a-9efd-4d3a-8e49-2add970014aa) |
| :---: |
| |

Инициация передачи на плате [A<sup>3</sup>T](A3T_Datasheet_ru.md) осуществляется изменением логического уровня на пине 4 (разъем XS2) с высокого на низкой, т.е. подтяжкой его к земле (GND), которая присутствует в изобилии на разъеме XS2 - это все нечетные пины. 
Таким образом, для того, чтобы плата излучила сигнал требуется соединить пин 4 c любым нечетным пином на этом же разъеме, например, с пином 3. 

Это можно сделать при помощи обычной кнопки, или платы с МК. Вот пример простого скетча для Arduino, который переключает пин D4 в низкий логический уровень на 10 мс раз в секунду:

#### 1.2.2. Скетч №1 - Инициация передачи 1 раз в секунду
  
```c
/* 
 * На пине A3T_TX_ENGAGE_PIN генерирует уровень A3T_TX_ACTIVE_STATE на DURATION_TKS микросекунд
 * через каждые PERIOD_TKS микросекунд. Изменение дублируется на встроенный светодиод
*/

#define A3T_TX_ENGAGE_PIN     (4)     // Этот пин необходимо соединить с пином 4 (разъем XS2) на модуле передатчика
                                      // Так же необходимо соединить пин GND на Arduino с пином 3 (разъем XS2)
#define A3T_TX_ACTIVE_STATE   (LOW)
#define A3T_TX_INACTIVE_STATE (HIGH)
#define LED_PIN               (13)
#define DURATION_TKS          (10000)
#define PERIOD_TKS            (1000000 - DURATION_TKS)

bool state;
uint32_t switch_tks;
uint32_t tks;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, A3T_TX_INACTIVE_STATE);

  for (int i = 0; i < 10; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    delay(100);
  }
}

void loop() {  

  tks = micros();

  if (state) {
    if (tks - switch_tks > DURATION_TKS) {
      digitalWrite(A3T_TX_ENGAGE_PIN, A3T_TX_INACTIVE_STATE);
      digitalWrite(LED_PIN, LOW);
      switch_tks = tks;
      state = false;
    }
  } else {
    if (tks - switch_tks > PERIOD_TKS) {        
      digitalWrite(A3T_TX_ENGAGE_PIN, A3T_TX_ACTIVE_STATE);
      digitalWrite(LED_PIN, HIGH);
      switch_tks = tks;
      state = true;
    }
  }
}
```

После перевода пина 4 в состояние низкого логического уровня модуль излучит акустический сигнал. Повторное излучение возможно не ранее чем через 40 мсек.

Если при этом модуль приемника детектирует переданный сигнал, он переведет пин 1 на разъеме XS3 в состояние низкого логического уровня на 2 мсек. 
В этом примере, факт приема сигнала будем определять при помощи платы Arduino Nano, но при наличии осциллографа в этом можно легко убедиться и без платы с микроконтроллером.

#### 1.2.3. Скетч №2 - Зажигаем светодиод по факту приема акустического сигнала

```c
/* По внешнему прерыванию на A3R_STATE_PIN (по спаду) включается встроенный светодиод, который гаснет через 
 * LED_DURATION_TKS микросекунд
*/

#define A3R_STATE_PIN    (2)      // Этот пин необходимо соединить с пином 1 (разъем XS3) на модуле приемника
                                  // Так же необходимо соединить пин GND на Arduino с пином 1 на модуле приемника
#define LED_PIN          (13)
#define LED_DURATION_TKS (10000)

bool led_state;
uint32_t led_on_tks;
uint32_t tks;

void a3r_state_changed_interrupt_handler() {

  led_state = true;
  digitalWrite(LED_PIN, HIGH);
  led_on_tks = micros();
}

void setup() {
  
  pinMode(LED_PIN, OUTPUT);
  pinMode(A3R_STATE_PIN, INPUT);
  attachInterrupt(digitalPinToInterrupt(A3R_STATE_PIN), a3r_state_changed_interrupt_handler, FALLING);

  for (int i = 0; i < 10; i++) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    delay(100);
  }
}

void loop() {  

  if (led_state) {
    tks = micros();
    if (tks - led_on_tks > LED_DURATION_TKS) {
      digitalWrite(LED_PIN, LOW);
      led_state = false;
    }
  }
}
```

Итак, к обоим модулям подключены платы с МК, модули и платы Arduino запитаны. В результате передатчик будет инициироваться каждую секунду, на подключенной к нему плате Arduino синхронно с передачей будет загораться светодиод, а гидроакустическая антенна будет щелкать.

Для того, чтобы проверить передачу сигнала на воздухе, достаточно расположить излучающую и приемные антенны в непосредственной близости друг от друга, как правило устойчивая работа обеспечивается, если между антеннами не более 10-15 см.

При успешном приеме акустического сигнала, приемный модуль будет инициировать прерывание на плате Arduino и на ней тоже будет загораться светодиод.

Вот как может выглядеть вся лабораторная установка:

| ![image](https://github.com/user-attachments/assets/76dd271a-f87e-45c2-bbad-dad94bc4ccd2) |
| :---: |
| |

При работе на водоеме или в бассейне крайне желательно обеспечивать достаточное заглубление антенн - и излучающая и приемные антенны должны быть опущены не менее 1 метра ниже поверхности воды.

### 1.3. Кратко о многолучевости и защитных интервалах
Многолучевость и методы борьбы с ней — крайне, крайне обширная тема, и здесь мы лишь кратко её коснёмся.

Каждый хоть раз в жизни сталкивался с эхом. Многолучевость — во многом близкое понятие. Если несколько упростить, можно сказать, что звук от источника распространяется сферическим фронтом. В каждой точке этого фронта можно провести к нему перпендикуляр — это называется лучом. В приёмник может попасть так называемый «прямой» луч и множество отражённых и преломлённых лучей. Часто все эти отражения сливаются в одно большое, постепенно затухающее послезвучие. Реже — например, в больших акваториях — можно наблюдать отдельные отражения, приходящие с существенной задержкой.

Отрицательные эффекты здесь очевидны: можно не только измерить «не ту» наклонную дальность, но и загнать маяк-ответчик в бесконечный цикл «запрос–ответ», когда его ответный сигнал, принятый им же, будет воспринят как новый запрос — и так до бесконечности. В реальности не используют одну и ту же частоту для запроса и ответа, но мы сейчас работаем с простейшим набором универсального оборудования.

При работе с простыми сигналами (чем мы в данный момент и занимаемся при помощи ACubes) практически единственным доступным методом борьбы с многолучевостью является так называемый защитный интервал. После детектирования сигнала приёмник выдерживает некоторую паузу, в течение которой не анализирует входной сигнал (или анализирует, но никак не реагирует). Длительность этого интервала сильно зависит от конкретных условий в конкретной акватории, и обычно для достижения устойчивого результата потребуются эксперименты.

### 1.4. Сценарий №2 - Собираем приемопередатчик и измеряем наклонную дальность
В ходе данной работы мы соберем два приемопередатчика, один из которых будет выполнять функцию маяка-ответчика, а другой сможет излучать запросный сигнал, ожидать ответный и по времени распространения сигнала и скорости звука определять наклонную дальность между абонентами.

#### 1.4.1. Требуемый набор оборудования

| №    | Наименование | Количество | Примечание |
| :--- | :--- | :--- | :--- |
| 1    | Модуль [A<sup>3</sup>R](A3R_Datasheet_ru.md) | 2 |  |
| 2    | Модуль [A<sup>3</sup>T](A3T_Datasheet_ru.md) | 2 |  |
| 3    | Антенна приемопередающая [RT-1.332820-1](/documentation/RU/Transducers/RT_1_332820_1_Specification_ru.md) | 2 |  |
| 4    | Любая плата с МК, например, Arduino Nano | 2 |  |
| 5    | LCD-экран, например MT-204S | 1 | Для отображения измеренного времени и дальности, но можно выводить и в COM-порт |
| 6    | Провода Dupont Female-Female или Male-Female, 25+ см | 15 | |

На самом деле данный сценарий содержит в себе как минимум два разных подсценария:  
**первый** подразумевает установку перемычки **P0** на маяке-ответчике, таким образом, чтобы выход приемника был соединен со входом передатчика. И маяк-ответчик в этом случае будет излучать ответный сигнал с нулевой задержкой. Казалось бы, схема наиболее удобная и максимально простая, но такой подход накладывает определенные ограничения. Дело в том, что у приемных модулей есть т.н. защитный интервал, который определяет, через какое время после приема возможен следующий прием. В свою очередь это означает, что у такой системы будет некоторая минимальная дальность, расстояние меньше которой измерить не получится - в момент прихода ответного сигнала с расстояния, меньше минимального, приемник будет ожидать завершения защитного интервала и будет невосприимчив.

Во **втором** подсценарии мы вводим фиксированную задержку между приемом запросного сигнала и излучением ответа. Значение этой задержки известно на запрашивающем устройстве и может быть легко учтено. Такая схема хоть и сложнее, но позволяет измерять расстояния почти до нулевого. Для формирования этой задержки удобнее всего воспользоваться каким-нибудь МК, например, той же Arduino.

Итак, начнем с запрашивающего устройства. Опять же, мы подготовили два варианта разной сложности - с использованием экрана и без - с передачей необходимой информации по UART.

#### 1.4.2. Запрашивающее устройство
Сначала соберем "бутерброд" из модулей A<sup>3</sup>R и A<sup>3</sup>T. Зададим адреc приемника на шине, установив джампер P1. Это сделано для того, чтобы все подключение к плате Arduinо было на разъеме XS2. Оплетку и минус антенны спаиваем вместе. Платы приемника и передатчика соединяем перемычками из отрезков проводов через разъемы XS1

| ![image](https://github.com/user-attachments/assets/d4376f61-762a-4d25-8e14-e6fb466bdc52) |
| :---: |
| |

Далее, подключаем сборку кубиков к плате Arduino. Для этого потребуется 4 провода папа-мама.

| ![image](https://github.com/user-attachments/assets/af9ca034-c4bb-451c-ab49-99c504a420cf) |
| :---: |
| |

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 2 / Строб при начале передачи | 3 / INT1 |
| 4 / Инициация передачи импульса | 10 |
| 6 / Строб приемника №1 | 2 / INT0 |

Если вы планируете использовать LCD-экран МЭЛТ МТ-20S4S или совместимый, то необходимо соединить пины следующим образом:

| Номер контакта на экране | Номер/Наименование контакта На Arduino Nano|
| :--- | :--- |
| 1 | GND |
| 2 | 5V |
| 4 | 8 (D8) |
| 5 | 9 (D9) |
| 10 | 4 (D4) |
| 11 | 5 (D5) |
| 12 | 6 (D6) |
| 13 | 7 (D7) |

Кроме того, необходимо на плате экрана соединить контакты 1-5 и 2-18, а так же контакты 2-3 между собой. Сопротивление между контактами 2-3 задает контрастность экрана, и в не которых случаях простого их замыкания может оказаться недостаточно. 

Ниже представлен скетч для управляющей платы Arduino: 

##### 1.4.2.1. Скетч #3 - Инициирует передачу и измеряет время между запросом и ответом
Если использование экрана не планируется, необходимо закомментировать строчку `#define USE_LCD`. Скорость звука задана константой 1500.0, для более точного значения предлагаем обратиться к нашему онлайн-калькулятору скорости звука в воде: [Толковый калькулятор скорости звука в воде](https://docs.unavlab.com/online_utils/proper_speed_of_sound_calculator.html)

```c
#define USE_LCD

#ifdef USE_LCD
#include "LiquidCrystal.h"
LiquidCrystal lcd(8, 9, 4, 5, 6, 7); // RS, E, D4-D7
#define X_MAX              (20) // Число символов на строчку экрана
#define MSG_LINE           (4)  // Номер строки для сообщения
#define W_LINE             (0)  // Номер стоки для отображения прогресса
int c_idx = 0;
#endif

#define A3R_STATE_PIN      (2)  // Пин, куда заводится строб от приемника
#define A3T_STATE_PIN      (3)  // Пин, куда заводится строб от передатчика
#define A3T_TX_ENGAGE_PIN  (10) // Пин, управляющий началом передачи на модуле передатчика

#define TKS_PER_S          (1000314L) // Число "микросекунд" в одной секунде на плате Arduino Nano

#define RX_DT_MS           (80L) // Защитный интервал для отсеивания сигнала локального передатчика, [мс]
#define RX_DT_TKS          (RX_DT_MS * 1000)

#define ANSWER_DELAY_MS    (100L) // Фиксированная задержка ответа на ответчике, [мс]
#define ANSWER_DELAY_TKS   (ANSWER_DELAY_MS * 1000)

#define SOS_MPS            (1500.0) // Скорость звука, [м/с]
#define MAX_DIST_M         (500L)    // Максимальная дальность, м

#define TIMEOUT_TKS        (ANSWER_DELAY_TKS + TKS_PER_S * (MAX_DIST_M * 2) / SOS_MPS) // Длительность интервала ожидвания ответа
#define STATE_TIMEOUT_TKS  (TIMEOUT_TKS * 3)                                              
#define TKS_PER_CHAR       ((TIMEOUT_TKS) / (X_MAX))

volatile int      state = 0; // Состояние
volatile uint32_t tks;       // Переменная для текущего времени, [мкс]
volatile uint32_t tot;       // Time of Transaction start, время начала транзакции, [мкс]
volatile uint32_t tor;       // Time of Radiation start - время начала излучения запросного сигнала, [мкс]
volatile uint32_t toa;       // Time of arriaval - момент прихода ответного сигнала, [мкс]

float    tof; // Time of flight - переменная для времени распространения
float    srn; // Slant range - наклонная дальность

void a3t_state_changed_interrupt_handler() {

  tor = micros();
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
  state = 2;
}

void a3r_state_changed_interrupt_handler() {
  
  if (state == 3) {
    toa = micros();
    state = 4;
  }
  
}

void setup() {

#ifdef USE_LCD
  lcd.begin(20, 4);
  lcd.clear();
#endif

  Serial.begin(9600);

  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);

  pinMode(A3T_STATE_PIN, INPUT);
  attachInterrupt(digitalPinToInterrupt(A3T_STATE_PIN), a3t_state_changed_interrupt_handler, FALLING);

  pinMode(A3R_STATE_PIN, INPUT);
  attachInterrupt(digitalPinToInterrupt(A3R_STATE_PIN), a3r_state_changed_interrupt_handler, FALLING);
}

void loop() {  

  switch (state) {

    case 0: 
      state = 1;
      tot = micros();
    
#ifdef USE_LCD
      lcd.setCursor(0, W_LINE);
      lcd.print("                    ");
      
      digitalWrite(A3T_TX_ENGAGE_PIN, LOW);
#endif
    break;

    case 1:


    break;

    case 2:
      tks = micros();
      if (tks - tor > RX_DT_TKS)
        state = 3;
      break;

    case 3:
      tks = micros();

      if (tks - tor > TIMEOUT_TKS) {

#ifdef USE_LCD
        lcd.setCursor(0, MSG_LINE);
        lcd.print("      TIMEOUT       ");
#endif

        Serial.print("TIMEOUT\r\n");
        state = 5;

      } else {

#ifdef USE_LCD
        c_idx = (int)((tks - tor)/TKS_PER_CHAR);
        if (c_idx > 20) 
          c_idx = 20;
        lcd.setCursor(c_idx, W_LINE);
        lcd.print(")");
#endif

      }
      
    break;

    case 4:

      tof = (int32_t)(toa - tor) - (int32_t)ANSWER_DELAY_TKS;
      tof /= 2.0;
      tof /= (float)TKS_PER_S;
      srn = tof * SOS_MPS;

#ifdef USE_LCD
      lcd.setCursor(0, MSG_LINE);
      lcd.print("                    ");
      lcd.setCursor(0, MSG_LINE);
      lcd.print(srn, 1);    
      lcd.print(" m");
#endif

      Serial.println(srn, 1);

      state = 5;
    break;
  }

  tks = micros();
  if (tks - tot > STATE_TIMEOUT_TKS) {
    state = 0;
  }
}

```

Как видно, информация отображается на экране и передается по UART, что можно наблюдать при помощи утилиты Serial Monitor прямо в среде Arduino IDE.

#### 1.4.3. Маяк-ответчик. Вариант №1 - без Arduino
Здесь нам необходимо собрать такой же "бутерброд", как и для запрашивающего устройства, с тем лишь отличием, что мы устанавливаем джампер **P0**, который замыкает выход приемника и вход передатчика. Строб от приемника при получении сигнала станет стробом, инициирующим передачу. Также не забудем установить джампер для задания адреса приемника на шине - это позволит вывести его на разъем XS2.

| ![image](https://github.com/user-attachments/assets/4f5f288b-7dd7-45a7-bfdb-2fee609555d9) |
| :---: |
| |

Антенну подключаем таким же образом, как и для запрашивающего устройства: оплетка и минус спаяны, перемычками соединены разъемы XS1 приемника и передатчика. 
Отметим, что питание и в случае запрашивающего устройства и в случае маяка-ответчика необходимо подавать на передающий модуль, чтобы избежать прохождение существенных токов по шине в момент излучения.

#### 1.4.4. Маяк-ответчик. Вариант №2 - с Arduino и фиксированной задержкой.
В этом случае в скетче для Arduino запрашивающего устройства необходимо задать какое-то ненулевое значение `ANSWER_DELAY_MS`. И у платы приемника и у платы передатчика длительность защитного интервала составляет 40 мсек. Соответственно, выбираемая длительность фиксированной задержки должна быть больше этого значения. 

Кроме изменения значения `ANSWER_DELAY_MS` в скетче в запращивающим устройстве не потребуется никаких изменений. А к маяку-ответчику теперь необходимо убрать джампер **P0** и подключить вторую плату Arduino Nano, согласно следующей таблице:

| Номер/Наименование контакта на XS2 | Номер/Наименование контакта на Arduino Nano |
| :--- | :--- |
| 1 / GND  | GND |
| 4 / Инициация передачи импульса | 10 |
| 6 / Строб приемника №1 | 2 / INT0 |

Вот так может выглядеть незамысловатый скетч, который ожидает приема сигнала, выдерживает паузу и излучает ответный сигнал:

##### 1.4.4.1. Скетч #4 - Фиксированная задержка ответа
  
```c
#define A3R_STATE_PIN     (2)
#define A3T_TX_ENGAGE_PIN (10)
#define LED_PIN           (13)

#define ANSWER_DELAY_MS    (100L) // Фиксированная задержка ответа на ответчике, [мс]
#define DEAD_TIME_MS       (100L) // Защитный интервал после излучения

#define TX_STROBE_DURATION_MS  (10L)

int curr_state = HIGH;

void setup() {

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);

  pinMode(A3T_TX_ENGAGE_PIN, OUTPUT);
  digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);

  pinMode(A3R_STATE_PIN, INPUT_PULLUP);
}

void loop() {

  curr_state = digitalRead(A3R_STATE_PIN);

  if ((curr_state == LOW)) {
    
    delay(ANSWER_DELAY_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, LOW);
    digitalWrite(LED_PIN, HIGH);
    delay(TX_STROBE_DURATION_MS);
    digitalWrite(A3T_TX_ENGAGE_PIN, HIGH);
    delay(DEAD_TIME_MS);
    digitalWrite(LED_PIN, LOW);    
  }
}

```


<div style="page-break-after: always;"></div>
