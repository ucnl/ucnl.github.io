<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NMEA Parser Demo - Подсветка веток</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: white;
            color: black;
            line-height: 1.4;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .code-container {
            flex: 1;
            border: 1px solid #ccc;
            padding: 10px;
            overflow-x: auto;
            font-size: 11px;
        }
        
        .state-container {
            flex: 1;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 13px;
        }
        
        .code-line {
            white-space: pre;
            padding: 2px 5px;
            border-left: 3px solid transparent;
            font-size: 10px;
            line-height: 1.2;
            min-height: 14px;
            color: #666;
        }
        
        .code-line.executed-line {
            background-color: #ffffcc;
        }
        
        .code-line.current-line {
            background-color: #ffff99;
            border-left: 3px solid #ff9900;
            font-weight: bold;
            color: #000;
        }
        
        .control-panel {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ccc;
        }
        
        textarea {
            font-family: 'Courier New', monospace;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            width: 100%;
            font-size: 14px;
        }
        
        button {
            font-family: 'Courier New', monospace;
            padding: 8px 16px;
            margin: 5px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        .state-field {
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }
        
        .state-field-name {
            font-weight: bold;
            color: #0066cc;
        }
        
        .state-field-value {
            color: #cc3300;
        }
        
        .status-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border: 1px solid #ddd;
            font-size: 13px;
        }
        
        .byte-info {
            font-family: 'Courier New', monospace;
            margin-left: 20px;
        }
        
        .branch-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f8ff;
            border: 1px solid #cce0ff;
            font-size: 12px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Демонстрация NMEA-парсера с подсветкой активной ветки</h1>
    
    <div class="control-panel">
        <h2>Ввод NMEA сообщения</h2>
        <textarea id="nmeaInput" rows="3" placeholder="Введите NMEA сообщение...">$GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47</textarea>
        
        <div style="margin-top: 10px;">
            <button id="stepBtn">СЛЕДУЮЩИЙ БАЙТ</button>
            <button id="autoBtn">АВТО</button>
            <button id="resetBtn">СБРОС</button>
            <span id="byteCounter" class="byte-info"></span>
        </div>
        
        <div class="status-info" id="statusInfo">Готово к работе</div>
    </div>
    
    <div class="container">
        <div class="code-container">
            <h2>Код парсера (C)</h2>
            <div id="codeDisplay"></div>
        </div>
        
        <div class="state-container">
            <h2>Состояние парсера</h2>
            <div id="stateDisplay"></div>
            
            <div class="branch-info">
                <strong>Выполненные строки на текущем шаге:</strong><br>
                <div id="executedLines" style="font-family: monospace; margin-top: 5px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Константы из C-кода
        const NMEA_SNT_STR = '$';
        const NMEA_SNT_END = '\n';
        const NMEA_CHK_SEP = '*';

        const NMEA_RESULT = {
            PACKET_READY: 0,
            BYPASS_BYTE: 1,
            PACKET_STARTED: 2,
            PACKET_PROCESS: 3,
            PACKET_CHECKSUM_ERROR: 4,
            PACKET_TOO_BIG: 5,
            PACKET_SKIPPING: 6,
            UNKNOWN: 7
        };

        const RESULT_NAMES = {
            0: "PACKET_READY",
            1: "BYPASS_BYTE", 
            2: "PACKET_STARTED",
            3: "PACKET_PROCESS",
            4: "PACKET_CHECKSUM_ERROR",
            5: "PACKET_TOO_BIG",
            6: "PACKET_SKIPPING",
            7: "UNKNOWN"
        };

        // Макрос для преобразования шестнадцатеричной цифры в число
        function STR_HEXDIGIT2B(char) {
            const c = char.charCodeAt(0);
            if (c >= 48 && c <= 57) return c - 48; // '0'-'9'
            if (c >= 65 && c <= 70) return c - 55; // 'A'-'F'
            if (c >= 97 && c <= 102) return c - 87; // 'a'-'f'
            return 0;
        }

        // Структура состояния парсера
        class NMEAState {
            constructor() {
                this.buffer = new Array(256).fill(0);
                this.buffer_size = 256;
                this.idx = 0;
                this.isReady = false;
                this.isStarted = false;
                this.isPSentence = false;
                this.chk_act = 0;
                this.chk_dcl = 0;
                this.chk_dcl_idx = 0;
                this.chk_present = false;
                this.tkrID = 0;
                this.sntID = 0;
                this.sntIDs = [
                    0x524D43, // NMEA_RMC_SNT_ID
                    0x474741, // NMEA_GGA_SNT_ID
                    0x474C4C, // NMEA_GLL_SNT_ID
                    0x475341, // NMEA_GSA_SNT_ID
                    0x475356, // NMEA_GSV_SNT_ID
                    0x565447, // NMEA_VTG_SNT_ID
                    0x484454, // NMEA_HDT_SNT_ID
                    0x484447, // NMEA_HDG_SNT_ID
                    0x5A4441, // NMEA_ZDA_SNT_ID
                    0x4D5457  // NMEA_MTW_SNT_ID
                ];
                this.sntIDs_size = this.sntIDs.length;
                this.lastResult = NMEA_RESULT.BYPASS_BYTE;
                this.currentLine = 0;
                this.executedLines = []; // Строки, выполненные на текущем шаге
            }

            reset() {
                this.buffer.fill(0);
                this.idx = 0;
                this.isReady = false;
                this.isStarted = false;
                this.isPSentence = false;
                this.chk_act = 0;
                this.chk_dcl = 0;
                this.chk_dcl_idx = 0;
                this.chk_present = false;
                this.tkrID = 0;
                this.sntID = 0;
                this.lastResult = NMEA_RESULT.BYPASS_BYTE;
                this.currentLine = 0;
                this.executedLines = [];
            }
        }

        // Функция парсера - возвращает все выполненные строки
        function NMEA_Process_Byte(uState, newByte) {
            let result = NMEA_RESULT.BYPASS_BYTE;
            let currentLine = 0;
            
            const byteChar = typeof newByte === 'string' ? newByte : String.fromCharCode(newByte);
            const byteCode = typeof newByte === 'string' ? newByte.charCodeAt(0) : newByte;
            
            // Сбрасываем список выполненных строк
            uState.executedLines = [];
            
            // Начинаем с первой строки
            uState.executedLines.push(3); // result = NMEA_RESULT_BYPASS_BYTE;
            currentLine = 3;
            
            // Определяем, какая строка выполняется
            if (!uState.isReady) {
                uState.executedLines.push(5); // if (!uState->isReady) {
                currentLine = 5;
                
                if (newByte === NMEA_SNT_STR) {
                    currentLine = 7;
                    uState.executedLines.push(7); // if (newByte == NMEA_SNT_STR) {
                    
                    uState.isStarted = true;
                    result = NMEA_RESULT.PACKET_STARTED;
                    
                    for (let i = 0; i < uState.buffer_size; i++) {
                        uState.buffer[i] = 0;
                    }
                    
                    uState.chk_act = 0;
                    uState.chk_dcl = 0;
                    uState.chk_dcl_idx = 0;
                    uState.idx = 0;
                    uState.tkrID = 0;
                    uState.sntID = 0;
                    uState.isPSentence = false;
                    
                    uState.buffer[uState.idx] = byteCode;
                    currentLine = 26;
                    uState.executedLines.push(26); // uState->buffer[uState->idx] = newByte;
                    uState.idx++;
                    currentLine = 27;
                    uState.executedLines.push(27); // uState->idx++;
                } else {
                    currentLine = 28;
                    uState.executedLines.push(28); // } else {
                    
                    if (uState.isStarted) {
                        currentLine = 29;
                        uState.executedLines.push(29); // if (uState->isStarted) {
                        result = NMEA_RESULT.PACKET_PROCESS;
                        currentLine = 31;
                        uState.executedLines.push(31); // result = NMEA_RESULT_PACKET_PROCESS;
                        
                        uState.buffer[uState.idx] = byteCode;
                        currentLine = 32;
                        uState.executedLines.push(32); // uState->buffer[uState->idx] = newByte;
                        
                        if (newByte === NMEA_SNT_END) {
                            currentLine = 34;
                            uState.executedLines.push(34); // if (newByte == NMEA_SNT_END) {
                            uState.isStarted = false;
                            currentLine = 36;
                            uState.executedLines.push(36); // uState->isStarted = false;
                            uState.isReady = true;
                            currentLine = 37;
                            uState.executedLines.push(37); // uState->isReady = true;
                            result = NMEA_RESULT.PACKET_READY;
                            currentLine = 38;
                            uState.executedLines.push(38); // result = NMEA_RESULT_PACKET_READY;
                        } else if (newByte === NMEA_CHK_SEP) {
                            currentLine = 39;
                            uState.executedLines.push(39); // } else if (newByte == NMEA_CHK_SEP) {
                            uState.chk_dcl_idx = 1;
                            currentLine = 41;
                            uState.executedLines.push(41); // uState->chk_dcl_idx = 1;
                            uState.chk_present = true;
                            currentLine = 42;
                            uState.executedLines.push(42); // uState->chk_present = true;
                        } else {
                            currentLine = 43;
                            uState.executedLines.push(43); // } else {
                            
                            if (uState.idx >= uState.buffer_size) {
                                currentLine = 44;
                                uState.executedLines.push(44); // if (uState->idx >= uState->buffer_size) {
                                uState.isStarted = false;
                                currentLine = 46;
                                uState.executedLines.push(46); // uState->isStarted = false;
                                result = NMEA_RESULT.PACKET_TOO_BIG;
                                currentLine = 47;
                                uState.executedLines.push(47); // result = NMEA_RESULT_PACKET_TOO_BIG;
                            } else {
                                currentLine = 48;
                                uState.executedLines.push(48); // } else {
                                
                                if (uState.chk_dcl_idx === 0) {
                                    currentLine = 49;
                                    uState.executedLines.push(49); // if (uState->chk_dcl_idx == 0) {
                                    uState.chk_act ^= byteCode;
                                    currentLine = 51;
                                    uState.executedLines.push(51); // uState->chk_act ^= newByte;
                                    
                                    // Ключевое исправление: для байтов данных (после заголовка)
                                    // нужно корректно определять, какая ветка выполняется
                                    
                                    if (uState.idx === 1) {
                                        currentLine = 52;
                                        uState.executedLines.push(52); // if (uState->idx == 1)
                                        if (newByte === 'P') {
                                            currentLine = 53;
                                            uState.executedLines.push(53); // if (newByte == NMEA_PSENTENCE_SYMBOL)
                                            uState.isPSentence = true;
                                            currentLine = 54;
                                            uState.executedLines.push(54); // uState->isPSentence = true;
                                        } else {
                                            currentLine = 55;
                                            uState.executedLines.push(55); // } else
                                            uState.tkrID = byteCode << 8;
                                            currentLine = 56;
                                            uState.executedLines.push(56); // uState->tkrID = ((uint16_t)newByte) << 8;
                                        }
                                    } else if (uState.idx === 2) {
                                        currentLine = 57;
                                        uState.executedLines.push(57); // else if (uState->idx == 2)
                                        if (uState.isPSentence) {
                                            currentLine = 58;
                                            uState.executedLines.push(58); // if (uState->isPSentence)
                                            uState.sntID = byteCode << 24;
                                            currentLine = 59;
                                            uState.executedLines.push(59); // uState->sntID = ((uint32_t)newByte) << 24;
                                        } else {
                                            currentLine = 60;
                                            uState.executedLines.push(60); // } else
                                            uState.tkrID |= byteCode;
                                            currentLine = 61;
                                            uState.executedLines.push(61); // uState->tkrID |= newByte;
                                        }
                                    } else if (uState.idx === 3) {
                                        currentLine = 62;
                                        uState.executedLines.push(62); // else if (uState->idx == 3)
                                        if (uState.isPSentence) {
                                            currentLine = 63;
                                            uState.executedLines.push(63); // if (uState->isPSentence)
                                            uState.sntID |= (byteCode << 16);
                                            currentLine = 64;
                                            uState.executedLines.push(64); // uState->sntID |= (((uint32_t)newByte) << 16);
                                        } else {
                                            currentLine = 65;
                                            uState.executedLines.push(65); // } else
                                            uState.sntID = byteCode << 16;
                                            currentLine = 66;
                                            uState.executedLines.push(66); // uState->sntID = (((uint32_t)newByte) << 16);
                                        }
                                    } else if (uState.idx === 4) {
                                        currentLine = 67;
                                        uState.executedLines.push(67); // else if (uState->idx == 4)
                                        uState.sntID |= (byteCode << 8);
                                        currentLine = 68;
                                        uState.executedLines.push(68); // uState->sntID |= (((uint32_t)newByte) << 8);
                                    } else if (uState.idx === 5) {
                                        currentLine = 69;
                                        uState.executedLines.push(69); // else if (uState->idx == 5) {
                                        uState.sntID |= byteCode;
                                        currentLine = 70;
                                        uState.executedLines.push(70); // uState->sntID |= newByte;
                                        
                                        let i = 0;
                                        while ((i < uState.sntIDs_size) && (uState.sntID !== uState.sntIDs[i])) {
                                            i++;
                                        }
                                        currentLine = 73;
                                        uState.executedLines.push(73); // while ((i < uState->sntIDs_size) && ...
                                        
                                        if (i >= uState.sntIDs_size) {
                                            currentLine = 76;
                                            uState.executedLines.push(76); // if (i >= uState->sntIDs_size) {
                                            uState.isStarted = false;
                                            currentLine = 78;
                                            uState.executedLines.push(78); // uState->isStarted = false;
                                            result = NMEA_RESULT.PACKET_SKIPPING;
                                            currentLine = 79;
                                            uState.executedLines.push(79); // result = NMEA_RESULT_PACKET_SKIPPING;
                                        }
                                    } else {
                                        // Для байтов данных после заголовка (idx > 5)
                                        // Просто XOR с контрольной суммой, но НЕ изменяем currentLine
                                        // Вместо этого фиксируем, что выполнилась ветка "данные заголовка уже обработаны"
                                        currentLine = 51; // Остаемся на строке XOR
                                    }
                                } else if (uState.chk_dcl_idx === 1) {
                                    currentLine = 82;
                                    uState.executedLines.push(82); // } else if (uState->chk_dcl_idx == 1) {
                                    uState.chk_dcl = 16 * STR_HEXDIGIT2B(byteChar);
                                    currentLine = 84;
                                    uState.executedLines.push(84); // uState->chk_dcl = 16 * STR_HEXDIGIT2B(newByte);
                                    uState.chk_dcl_idx++;
                                    currentLine = 85;
                                    uState.executedLines.push(85); // uState->chk_dcl_idx++;
                                } else if (uState.chk_dcl_idx === 2) {
                                    currentLine = 86;
                                    uState.executedLines.push(86); // } else if (uState->chk_dcl_idx == 2) {
                                    uState.chk_dcl += STR_HEXDIGIT2B(byteChar);
                                    currentLine = 88;
                                    uState.executedLines.push(88); // uState->chk_dcl += STR_HEXDIGIT2B(newByte);
                                    
                                    if (uState.chk_act !== uState.chk_dcl) {
                                        currentLine = 89;
                                        uState.executedLines.push(89); // if (uState->chk_act != uState->chk_dcl) {
                                        uState.isStarted = false;
                                        currentLine = 90;
                                        uState.executedLines.push(90); // uState->isStarted = false;
                                        result = NMEA_RESULT.PACKET_CHECKSUM_ERROR;
                                        currentLine = 91;
                                        uState.executedLines.push(91); // result = NMEA_RESULT_PACKET_CHECKSUM_ERROR;
                                    }
                                    uState.chk_dcl_idx++;
                                    currentLine = 93;
                                    uState.executedLines.push(93); // uState->chk_dcl_idx++;
                                }
                            }
                        }
                        
                        // uState.idx++ выполняется всегда в этом блоке
                        uState.idx++;
                        if (currentLine < 98) { // Чтобы не дублировать
                            currentLine = 98;
                            uState.executedLines.push(98); // uState->idx++;
                        }
                    }
                }
            } else {
                // Парсер готов, обрабатываем байт как BYPASS
                currentLine = 3;
                uState.executedLines.push(3); // result = NMEA_RESULT_BYPASS_BYTE;
            }
            
            uState.lastResult = result;
            uState.currentLine = currentLine || 0;
            
            return {result, line: uState.currentLine};
        }

        // Инициализация приложения
        let parserState = new NMEAState();
        let nmeaMessage = "";
        let currentByteIndex = 0;
        let autoInterval = null;

        // Оригинальный код парсера
        const codeLines = [
            "1: NMEA_Result_Enum NMEA_Process_Byte(NMEA_State_Struct* uState, uint8_t newByte) {",
            "2: ",
            "3:   NMEA_Result_Enum result = NMEA_RESULT_BYPASS_BYTE;",
            "4: ",
            "5:   if (!uState->isReady) {",
            "6: ",
            "7:     if (newByte == NMEA_SNT_STR) {",
            "8: ",
            "9:       uState->isStarted = true;",
            "10:       result = NMEA_RESULT_PACKET_STARTED;",
            "11: ",
            "12:       uint8_t i = 0;",
            "13:       for (i = 0; i < uState->buffer_size; i++)",
            "14:         uState->buffer[i] = 0;",
            "15: ",
            "16:       uState->chk_act     = 0;",
            "17:       uState->chk_dcl     = 0;",
            "18:       uState->chk_dcl_idx = 0;",
            "19:       uState->idx         = 0;",
            "20: ",
            "21:       uState->tkrID       = 0;",
            "22:       uState->sntID       = 0;",
            "23: ",
            "24:       uState->isPSentence = false;",
            "25: ",
            "26:       uState->buffer[uState->idx] = newByte;",
            "27:       uState->idx++;",
            "28:     } else {",
            "29:       if (uState->isStarted) {",
            "30: ",
            "31:         result = NMEA_RESULT_PACKET_PROCESS;",
            "32:         uState->buffer[uState->idx] = newByte;",
            "33: ",
            "34:         if (newByte == NMEA_SNT_END) {",
            "35: ",
            "36:           uState->isStarted = false;",
            "37:           uState->isReady = true;",
            "38:           result = NMEA_RESULT_PACKET_READY;",
            "39:         } else if (newByte == NMEA_CHK_SEP) {",
            "40: ",
            "41:           uState->chk_dcl_idx = 1;",
            "42:           uState->chk_present = true;",
            "43:         } else {",
            "44:           if (uState->idx >= uState->buffer_size) {",
            "45: ",
            "46:             uState->isStarted = false;",
            "47:             result = NMEA_RESULT_PACKET_TOO_BIG;",
            "48:           } else {",
            "49:             if (uState->chk_dcl_idx == 0) {",
            "50: ",
            "51:               uState->chk_act ^= newByte;",
            "52:               if (uState->idx == 1)",
            "53:                 if (newByte == NMEA_PSENTENCE_SYMBOL)",
            "54:                   uState->isPSentence = true;",
            "55:                 else",
            "56:                   uState->tkrID = ((uint16_t)newByte) << 8;",
            "57:               else if (uState->idx == 2)",
            "58:                 if (uState->isPSentence)",
            "59:                   uState->sntID = ((uint32_t)newByte) << 24;",
            "60:                 else",
            "61:                   uState->tkrID |= newByte;",
            "62:               else if (uState->idx == 3)",
            "63:                 if (uState->isPSentence)",
            "64:                   uState->sntID |= (((uint32_t)newByte) << 16);",
            "65:                 else",
            "66:                   uState->sntID = (((uint32_t)newByte) << 16);",
            "67:               else if (uState->idx == 4)",
            "68:                 uState->sntID |= (((uint32_t)newByte) << 8);",
            "69:               else if (uState->idx == 5) {",
            "70:                 uState->sntID |= newByte;",
            "71: ",
            "72:                 uint8_t i = 0;",
            "73:                 while ((i < uState->sntIDs_size) && (uState->sntID != uState->sntIDs[i]))",
            "74:                   i++;",
            "75: ",
            "76:                 if (i >= uState->sntIDs_size) {",
            "77: ",
            "78:                   uState->isStarted = false;",
            "79:                   result = NMEA_RESULT_PACKET_SKIPPING;",
            "80:                 }",
            "81:               }",
            "82:             } else if (uState->chk_dcl_idx == 1) {",
            "83: ",
            "84:               uState->chk_dcl = 16 * STR_HEXDIGIT2B(newByte);",
            "85:               uState->chk_dcl_idx++;",
            "86:             } else if (uState->chk_dcl_idx == 2) {",
            "87: ",
            "88:               uState->chk_dcl += STR_HEXDIGIT2B(newByte);",
            "89:               if (uState->chk_act != uState->chk_dcl) {",
            "90:                 uState->isStarted = false;",
            "91:                 result = NMEA_RESULT_PACKET_CHECKSUM_ERROR;",
            "92:               }",
            "93:               uState->chk_dcl_idx++;",
            "94:             }",
            "95:           }",
            "96:         }",
            "97: ",
            "98:         uState->idx++;",
            "99:       }",
            "100:     }",
            "101:   }",
            "102:   return result;",
            "103: }"
        ];

        // Функции для обновления интерфейса
        function updateCodeHighlight(lineNumber, executedLines) {
            const codeDisplay = document.getElementById('codeDisplay');
            codeDisplay.innerHTML = '';
            
            codeLines.forEach((line, index) => {
                const lineNum = index + 1;
                const lineElement = document.createElement('div');
                lineElement.className = 'code-line';
                lineElement.textContent = line;
                
                // Проверяем, была ли эта строка выполнена
                if (executedLines.includes(lineNum)) {
                    lineElement.classList.add('executed-line');
                }
                
                // Проверяем, является ли строка текущей выполняемой строкой
                if (lineNum === lineNumber) {
                    lineElement.classList.add('current-line');
                }
                
                codeDisplay.appendChild(lineElement);
            });
        }

        function bufferToString(buffer, idx) {
            let result = '';
            
            const startIdx = Math.max(0, idx - 40);
            const displayLength = Math.min(40, idx);
            
            for (let i = startIdx; i < idx; i++) {
                const val = buffer[i];
                if (val === 0 || val === '0' || val === '' || val === null || val === undefined) {
                    result += '·';
                } else if (val === 10 || val === '\n') {
                    result += '\\n';
                } else if (val === 13 || val === '\r') {
                    result += '\\r';
                } else if (typeof val === 'number') {
                    if (val < 32 || val >= 127) {
                        result += '.';
                    } else {
                        result += String.fromCharCode(val);
                    }
                } else if (typeof val === 'string') {
                    const code = val.charCodeAt(0);
                    if (code < 32 || code >= 127) {
                        result += '.';
                    } else {
                        result += val;
                    }
                } else {
                    result += '.';
                }
            }
            
            if (idx > 40) {
                result = '...' + result;
            }
            
            return result;
        }

        function updateStateDisplay() {
            const stateDisplay = document.getElementById('stateDisplay');
            stateDisplay.innerHTML = '';
            
            const fields = [
                {name: 'buffer (last 40 chars)', value: `"${bufferToString(parserState.buffer, parserState.idx)}"`},
                {name: 'buffer_size', value: parserState.buffer_size},
                {name: 'idx', value: parserState.idx},
                {name: 'isReady', value: parserState.isReady ? 'true' : 'false'},
                {name: 'isStarted', value: parserState.isStarted ? 'true' : 'false'},
                {name: 'isPSentence', value: parserState.isPSentence ? 'true' : 'false'},
                {name: 'chk_act', value: `0x${parserState.chk_act.toString(16).toUpperCase().padStart(2, '0')} (${parserState.chk_act})`},
                {name: 'chk_dcl', value: `0x${parserState.chk_dcl.toString(16).toUpperCase().padStart(2, '0')} (${parserState.chk_dcl})`},
                {name: 'chk_dcl_idx', value: parserState.chk_dcl_idx},
                {name: 'chk_present', value: parserState.chk_present ? 'true' : 'false'},
                {name: 'tkrID', value: `0x${parserState.tkrID.toString(16).toUpperCase().padStart(4, '0')}`},
                {name: 'sntID', value: `0x${parserState.sntID.toString(16).toUpperCase().padStart(6, '0')}`},
                {name: 'lastResult', value: `${parserState.lastResult} (${RESULT_NAMES[parserState.lastResult]})`},
                {name: 'currentLine', value: parserState.currentLine || '0'},
            ];
            
            fields.forEach(field => {
                const fieldElement = document.createElement('div');
                fieldElement.className = 'state-field';
                fieldElement.innerHTML = `<span class="state-field-name">${field.name}:</span> <span class="state-field-value">${field.value}</span>`;
                stateDisplay.appendChild(fieldElement);
            });
            
            // Обновляем отображение выполненных строк
            const executedLinesElement = document.getElementById('executedLines');
            if (parserState.executedLines && parserState.executedLines.length > 0) {
                const lines = [...new Set(parserState.executedLines)].sort((a, b) => a - b);
                executedLinesElement.textContent = lines.join(', ');
            } else {
                executedLinesElement.textContent = 'Нет выполненных строк';
            }
        }

        function updateStatusInfo(result, byte) {
            const statusInfo = document.getElementById('statusInfo');
            let byteDisplay;
            
            if (byte === '\n') {
                byteDisplay = "\\n (LF, конец сообщения)";
            } else if (byte === '\r') {
                byteDisplay = "\\r (CR)";
            } else if (byte === '$') {
                byteDisplay = "'$' (начало сообщения)";
            } else if (byte === '*') {
                byteDisplay = "'*' (разделитель контрольной суммы)";
            } else if (byte === ',') {
                byteDisplay = "',' (разделитель полей)";
            } else if (typeof byte === 'string') {
                const code = byte.charCodeAt(0);
                byteDisplay = `'${byte}' (0x${code.toString(16).toUpperCase()})`;
            } else {
                byteDisplay = `0x${byte.toString(16).toUpperCase()}`;
            }
            
            statusInfo.innerHTML = `
                <strong>Обработан байт:</strong> ${byteDisplay}<br>
                <strong>Результат:</strong> ${RESULT_NAMES[result]}<br>
                <strong>Текущая строка кода:</strong> ${parserState.currentLine}<br>
                <strong>Прогресс:</strong> ${currentByteIndex}/${nmeaMessage.length} байт
            `;
        }

        function processNextByte() {
            if (currentByteIndex >= nmeaMessage.length) {
                stopAutoMode();
                document.getElementById('statusInfo').innerHTML = 
                    '<strong>Сообщение полностью обработано</strong><br>' +
                    'Добавьте \\n в конец сообщения для завершения парсинга';
                return;
            }
            
            const byte = nmeaMessage[currentByteIndex];
            const result = NMEA_Process_Byte(parserState, byte);
            
            updateCodeHighlight(result.line, parserState.executedLines);
            updateStateDisplay();
            updateStatusInfo(result.result, byte);
            
            document.getElementById('byteCounter').textContent = 
                `Байт: ${currentByteIndex + 1}/${nmeaMessage.length}`;
            
            currentByteIndex++;
            
            // Если пакет готов или ошибка, останавливаем авторежим
            if (result.result === NMEA_RESULT.PACKET_READY || 
                result.result === NMEA_RESULT.PACKET_CHECKSUM_ERROR ||
                result.result === NMEA_RESULT.PACKET_TOO_BIG ||
                result.result === NMEA_RESULT.PACKET_SKIPPING) {
                stopAutoMode();
            }
        }

        function startAutoMode() {
            if (autoInterval) return;
            
            autoInterval = setInterval(() => {
                if (currentByteIndex >= nmeaMessage.length) {
                    stopAutoMode();
                    return;
                }
                processNextByte();
            }, 200);
            
            document.getElementById('autoBtn').textContent = 'СТОП';
        }

        function stopAutoMode() {
            if (autoInterval) {
                clearInterval(autoInterval);
                autoInterval = null;
                document.getElementById('autoBtn').textContent = 'АВТО';
            }
        }

        function resetParser() {
            stopAutoMode();
            parserState.reset();
            
            // Берем сообщение из поля ввода и добавляем \n если его нет
            nmeaMessage = document.getElementById('nmeaInput').value;
            if (nmeaMessage.length > 0 && nmeaMessage[nmeaMessage.length - 1] !== '\n') {
                nmeaMessage += '\n';
            }
            
            currentByteIndex = 0;
            
            updateCodeHighlight(0, []);
            updateStateDisplay();
            document.getElementById('byteCounter').textContent = '';
            document.getElementById('statusInfo').innerHTML = 
                '<strong>Готово к работе</strong><br>' +
                'Сообщение будет автоматически дополнено символом \\n';
        }

        // Инициализация событий
        document.getElementById('stepBtn').addEventListener('click', () => {
            if (currentByteIndex === 0) {
                // При первом шаге берем сообщение и добавляем \n
                nmeaMessage = document.getElementById('nmeaInput').value;
                if (nmeaMessage.length > 0 && nmeaMessage[nmeaMessage.length - 1] !== '\n') {
                    nmeaMessage += '\n';
                }
            }
            processNextByte();
        });

        document.getElementById('autoBtn').addEventListener('click', () => {
            if (currentByteIndex === 0) {
                nmeaMessage = document.getElementById('nmeaInput').value;
                if (nmeaMessage.length > 0 && nmeaMessage[nmeaMessage.length - 1] !== '\n') {
                    nmeaMessage += '\n';
                }
            }
            
            if (autoInterval) {
                stopAutoMode();
            } else {
                startAutoMode();
            }
        });

        document.getElementById('resetBtn').addEventListener('click', resetParser);

        // Инициализация при загрузке
        document.addEventListener('DOMContentLoaded', () => {
            updateCodeHighlight(0, []);
            updateStateDisplay();
            // Инициализируем сообщение с добавлением \n
            nmeaMessage = document.getElementById('nmeaInput').value;
            if (nmeaMessage.length > 0 && nmeaMessage[nmeaMessage.length - 1] !== '\n') {
                nmeaMessage += '\n';
            }
        });
    </script>
</body>
</html>