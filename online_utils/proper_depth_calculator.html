<head>
<title>Proper depth calculator</title>
<link href="style.css" rel="stylesheet" type="text/css">
<!-- Yandex.Metrika counter -->
<script type="text/javascript">
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
   ym(28716631, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/28716631" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<script src="https://ucnl.github.io/UCNLPhysics/JS/ucnlphysics.js" type="text/javascript"></script>
</head>

<body>
<h1>(beta) Proper water properties calculator: Depth</h1>
<hr>
<p><b>Warning!</b><br>
<i>If you calculate water depth assuming constant water density and constant gravity acceleration, you do it in a wrong way.<br>
Take a look at this simple water depth calculator to make you estimations more precise and accurate!<br></i>
</p>

<h2>0. Brief description. Very basic theory.</h2>
<P>
Calculation of depth by a given hydrostatic pressure comes from a simple equation:
<br>
<br>
<b><i>P = &rho; &middot; g &middot; h</i></b>
<br>
<br>
Where <b><i>P</i></b> is pressure, generated by the water column with height <b><i>h</i></b> and density <b><i>&rho;</i></b>.
The depth <b><i>h</i></b> can be estimated as follows:
<br>
<br>
<b><i>h = (P - P<sub>0</sub>) / (&rho; &middot; g)</i></b>
<br>
<br>
Where <b><i>P<sub>0</sub></i></b> - is the atmospheric pressure above the water surface.<br>
But neither <b><i>&rho;</i></b> nor <b><i>g</i></b> is constants.
As well as the atmospheric pressure <b><i>P<sub>0</sub></i></b> - which in some cases can vary hourly.<br>
<br>
Gravity constant <b><i>g</i></b> in the simple case is a function of geographic latitude.
Since the Earth rotates around an axis going through north and south poles, the gravity force is
lower on equator due to centrifugal forces and higher on poles.<br>
<br>
To estimate the adequate value of gravity acceleration we can use the WGS84 gravity formula
<sup><a href="#footnote1">[1]</a></sup><sup><a href="#footnote2">[2]</a></sup>.<br>
In real-world applications water density <b><i>&rho;</i></b> is a function of water
temperature <b><i>t</i></b>, salinity <b><i>s</i></b> and pressure <b><i>P</i></b>.
Its value can be estimated according to the UNESCO equation<sup><a href="#footnote3">[3]</a></sup>.
</p>

<br>
<h2>1. Depth calculation: an easy way</h2>
In this simplified calculation of water properties, we consider:<br>
<i>
- homogenous temperature and salinity in the whole water body;<br>
- water as non-compressible fluid (ok, almost).
</i>
<br>
<br>

<table id="c1_in_values_tbl">
<caption><b>Table 1. Input values</b></caption>
 <tr>
   <th>Parameter</th>
   <th>Notation</th>
   <th>Value</th>
   <th>Range</th>
   <th>Units</th>
 </tr>
 <tr>
   <td>Water temperature</td>
   <td><b><i>t</i></b></td>
   <td><input type="number" step="0.1" value="10" min="-4" max="40" name="c1_t_C" id="c1_t_C_input" onchange="c1_check_t()"></td>
   <td>-4 .. 40</td>
   <td>°C</td>
 </tr>
 <tr>
   <td>Atmosperic pressure</td>
   <td><b><i>P<sub>0</sub></i></b></td>
   <td><input type="number" step="0.01" value="1013.25" min="880" max="1085" name="c1_P0_mBar" id="c1_p0_mBar_input" onchange="c1_check_P0()"></td>
   <td>870 .. 1090</td>
   <td>mBar</td>
 </tr>
 <tr>
   <td>Hydrostatic pressure</td>
   <td><b><i>P</i></b></td>
   <td><input type="number" step="0.01" value="100000" min="1000" max="1200000" name="c1_P_mBar" id="c1_P_mBar_input" onchange="c1_check_P()"></td>
   <td>10<sup>3</sup> .. 10<sup>6</sup></td>
   <td>mBar</td>
 </tr>
 <tr>
   <td>Geographic latitude</td>
   <td><b><i>&phi;</i></b></td>
   <td><input type="number" step="0.001" value="48" min="-90" max="90" name="c1_phi_deg" id="c1_phi_deg_input" onchange="c1_check_phi()"></td>
   <td>-90 .. 90</td>
   <td>°</td>
 </tr>
 <tr>
   <td>Water salinity</td>
   <td><b><i>s</i></b></td>
   <td><input type="number" step="0.1" value="38" min="0" max="42" name="c1_s_PSU" id="c1_s_PSU_input" onchange="c1_check_s()"></td>
   <td>0 .. 42</td>
   <td>PSU</td>
 </tr>
</table>

<br>
<div>
    <button id="c1_run" onclick="c1_run()">CALCULATE</button>
</div>
<br>

<table id="c1_out_values_tbl">
<caption><b>Table 2. Output values</b></caption>
 <tr>
   <th>Parameter</th>
   <th>Notation</th>
   <th>Value</th>
   <th>Units</th>
   <th>Description</th>
 </tr>
 <tr>
   <td>Water density</td>
   <td><b><i>&rho;</i></b></td>
   <td><p id="c1_rho"></p></td>
   <td>kg/m<sup>3</sup></td>
   <td>For the point with given <b><i>P</i></b> and <b><i>t</i></b></td>
 </tr>
 <tr>
   <td>Gravity acceleration</td>
   <td><b><i>g</i></b></td>
   <td><p id="c1_g"></p></td>
   <td>m/s<sup>2</sup></td>
   <td>For the specified <b><i>&phi;</i></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>swg</sub></i></b></td>
   <td><p id="c1_h_swg"></p></td>
   <td>m</td>
   <td>For <b><i>&rho;=1023.6</i></b><sup><a href="#footnote4">[4]</sup></a> kg/m<sup>3</sup>,
      <b><i>g=9.80665</i></b><sup><a href="#footnote5">[5]</sup></a> m/s<sup>2</sup></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>sw</sub></i></b></td>
   <td><p id="c1_h_sw"></p></td>
   <td>m</td>
   <td>For <b><i>&rho;=1023.6</i></b><sup><a href="#footnote4">[4]</sup></a> kg/m<sup>3</sup>, <b><i>g=g(&phi;)</i></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>fwg</sub></i></b></td>
   <td><p id="c1_h_fwg"></p></td>
   <td>m</td>
   <td>For <b><i>&rho;=998.02</i></b><sup><a href="#footnote6">[6]</sup></a> kg/m<sup>3</sup>,
     <b><i>g=9.80665</i></b><sup><a href="#footnote5">[5]</sup></a> m/s<sup>2</sup></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>fw</sub></i></b></td>
   <td><p id="c1_h_fw"></p></td>
   <td>m</td>
   <td>For <b><i>&rho;=998.02</i></b><sup><a href="#footnote6">[6]</sup></a> kg/m<sup>3</sup>, <b><i>g=g(&phi;)</i></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>&rho;P<sub>0</sub></sub></i></b></td>
   <td><p id="c1_h_rho_P0"></p></td>
   <td>m</td>
   <td><b><i>&rho;=&rho;(t,P<sub>0</sub>,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>&rho;P</sub></i></b></td>
   <td><p id="c1_h_rho_P"></p></td>
   <td>m</td>
   <td><b><i>&rho;=&rho;(t,P,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
 </tr>
 <tr>
   <td>Depth</td>
   <td><b><i>h<sub>&rho;P<sub>m</sub></sub></i></b></td>
   <td><p id="c1_h_rho_Pm"></p></td>
   <td>m</td>
   <td><b><i>&rho;=&rho;<sub>m</sub>=&rho;(t,(P+P<sub>0</sub>)/2,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
 </tr>
</table>

<p>
It this calculation we assume that <b><i>h<sub>&rho;P<sub>m</sub></sub></i></b> is the most precise value.
Since the density of water <b><i>&rho;</i></b> depends on pressure <b><i>P</i></b> almost linearly,
we try to take into account the compressibility of water by calculating water density for the midpoint
<b><i>&rho;<sub>m</sub>=&rho;(t,(P+P<sub>0</sub>)/2,s)</i></b>.
</p>

<br>
<h2>2. Depth calculation: harder, but not a proper way</h2>
In this simplified calculation of water properties, we consider:<br>
<i>
- homogenous temperature and salinity in the whole water body;<br>
- water as compressible fluid.
</i>
<br>
<br>
To take into account the change of water density with the pressure we divide the pressure of
the whole water column by <b><i>N<sub>p</sub></i></b> parts, every lower part will have a
higher density (and smaller height) than higher part due to compression of water.
It means that to estimate the proper value of depth we should calculate the following sum:
<br>
<br>
<b><i>h = (&Delta;P / g) &middot; &sum; [1 / &rho;(t, P<sub>0</sub> + &Delta;Pi), s]</i></b>
<br>
<br>
Estimating the water density for all parts of the water column.<br>
<br>
We use all parameters from the <b>Table. 1</b> and adding only one extra parameter: number <b><i>N<sub>p</sub></i></b> of pressure intervals:<br>
</br>
<table id="c2_in_values_tbl">
<caption><b>Table 3. Input values</b></caption>
 <tr>
   <th>Parameter</th>
   <th>Notation</th>
   <th>Value</th>
   <th>Range</th>
   <th>Units</th>
 </tr>
 <tr>
   <td>Number of pressure intervals</td>
   <td><b><i>N<sub>p</sub></i></b></td>
   <td><input type="number" step="1" value="1000" min="2" max="99999" name="c2_N_p" id="c2_N_p_input" onchange="c2_check_Np()"></td>
   <td>2 .. 99999</td>
   <td></td>
 </tr>
 </table>

 <br>
 <div>
     <button id="c2_run" onclick="c2_run()">CALCULATE</button>
 </div>
 <br>

 <table id="c2_out_values_tbl">
 <caption><b>Table 4. Output values</b></caption>
  <tr>
    <th>Parameter</th>
    <th>Notation</th>
    <th>Value</th>
    <th>Units</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>Gravity acceleration</td>
    <td><b><i>g</i></b></td>
    <td><p id="c2_g"></p></td>
    <td>m/s<sup>2</sup></td>
    <td>For the specified <b><i>&phi;</i></b></td>
  </tr>

  <tr>
    <td>Depth</td>
    <td><b><i>h<sub>&rho;P<sub>0</sub></sub></i></b></td>
    <td><p id="c2_h_rho_P0"></p></td>
    <td>m</td>
    <td><b><i>&rho;=&rho;(t,P<sub>0</sub>,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
  </tr>
  <tr>
    <td>Depth</td>
    <td><b><i>h<sub>&rho;P</sub></i></b></td>
    <td><p id="c2_h_rho_P"></p></td>
    <td>m</td>
    <td><b><i>&rho;=&rho;(t,P,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
  </tr>
  <tr>
    <td>Depth</td>
    <td><b><i>h<sub>&rho;P<sub>m</sub></sub></i></b></td>
    <td><p id="c2_h_rho_Pm"></p></td>
    <td>m</td>
    <td><b><i>&rho;=&rho;<sub>m</sub>=&rho;(t,(P+P<sub>0</sub>)/2,s)</i></b>, <b><i>g=g(&phi;)</i></b></td>
  </tr>
  <tr>
    <td>Depth</td>
    <td><b><i>h<sub>&rho;</sub></i></b></td>
    <td><p id="c2_h_rho"></p></td>
    <td>m</td>
    <td><b><i>h = (&Delta;P / g) &middot; &sum; [1 / &rho;(t, P<sub>0</sub> + &Delta;Pi), s]</i></b>, <b><i>i=1..N<sub>p</sub></i></b>, <b><i>g=g(&phi;)</i></b></td>
  </tr>
 </table>

<p>
It this calculation we assume that <b><i>h<sub>&rho;</sub></i></b> is the most precise value.
</p>

<br>
<h2>3. Depth calculation: proper way</h2>
In this calculation of water properties, we consider:<br>
<i>
- temperature and salinity vary with depth according to a given profile;<br>
- water as compressible fluid.
</i>
<br>

<p>
To perform this calculation we take all the parameters from tables 1. and 3.
Also, we need a measured temperature and salinity profile.
TS-Profile is the number of measurements of temperature and salinity made in different depths.
</p>

<table id="c3_in_values_tbl">
<caption><b>Table 5. Input values</b></caption>
 <tr>
   <th>Parameter</th>
   <th>Notation</th>
   <th>Value</th>
   <th>Units</th>
 </tr>
 <tr>
   <td>Number of points</td>
   <td><b><i>N<sub>tsp</sub></i></b></td>
   <td><input type="number" step="1" value="12" min="1" max="100" name="c3_Nt" id="c3_Ntsp_input" onchange="c3_check_Ntsp()"></td>
   <td></td>
 </tr>
 <tr>
   <td>Z coordinate step</td>
   <td><b><i>Z<sub>s</sub></i></b></td>
   <td><input type="number" step="1" value="100" min="1" max="1000" name="z_step" id="c3_z_step_input" onchange="c3_check_ZStep()"></td>
   <td>m</td>
 </tr>
</table>

<p><input type="button" id="update_table_btn" value="RESET TABLE" onclick="updateTable_And_Set_TS_Const()"/></p>
<hr>
<p><input type="button" id="set_northern_ocean" value="Set typical northern pacific profile (39°N, 152°W)" onclick="set_Example_Northern_pacific_TS_profile()"/></p>
<p><input type="button" id="set_southern_atlantic_ocean" value="Set typical southern atlantic profile (20°S)" onclick="set_Example_Southern_Atlantic_TS_profile()"/></p>
<p><input type="button" id="set_arctic_ocean" value="Set typical arctic profile (85°N)" onclick="set_Example_Arctic_TS_profile()"/></p>
<hr>
<div id="cont"></div>

<p><input type="button" id="c3_run" value="CALCULATE" onclick="c3_run()"/></p>
<br>

<table id="c3_output_values_tbl">
<caption><b>Estimated depth values</b></caption>
 <tr>
   <th>Notation</th>
   <th>Value</th>
   <th>Units</th>
   <th>Description</th>
 </tr>
 <tr>
   <td><b>h<sub>ts</sub></b></td>
   <td><p id="c3_h_ts"></p></td>
   <td>m</td>
   <td><b><i>h = (&Delta;P / g) &middot; &sum; [1 / &rho;(t, P<sub>0</sub> + &Delta;Pi), s]</i></b>, <b><i>i=1..N<sub>p</sub></i></b>, <b><i>g=g(&phi;)</i></b>, <b><i>t=t(z)</i></b>, <b><i>s=s(z)</i></b></td>
 </tr>
</table>

<br>
<br>
<br>

<hr>
<ol>
    <li id="footnote1"><a href="https://en.wikipedia.org/wiki/Theoretical_gravity">Theoretical gravity on wikipedia</a>.
    <li id="footnote2"><a href="http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf">Department of Defense World Geodetic System 1984 ― Its Definition and Relationships with Local Geodetic Systems,NIMA TR8350.2, 3rd ed., Tbl. 3.4, Eq. 4-1</a>
    <li id="footnote3"><a href="http://www.vliz.be/imisdocs/publications/ocrd/270509.pdf">In situ water density. Millero et al 1980, deep-sea res.,27a,255-264, jpots ninth report 1978, tenth report 1980.</a>
    <li id="footnote4"><a href="https://doi.org/10.1016%2Fj.desal.2016.02.024">Nayar, Kishor G.; Sharqawy, Mostafa H.; Banchik, Leonardo D.; Lienhard V, John H. (July 2016). "Thermophysical properties of seawater: A review and new correlations that include pressure dependence". Desalination. 390: 1–24.</a>
    <li id="footnote5"><a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication330e2008.pdf">Taylor, Barry N.; Thompson, Ambler, eds. (March 2008). The international system of units (SI) (Report). National Institute of Standards and Technology. p. 52. NIST special publication 330, 2008 edition.</a>
    <li id="footnote6"><a href="https://ittc.info/media/7503/75-02-01-03.pdf">ITTC – Recommended Procedures 7.5-02-01-03. Fresh Water and Seawater Properties. Effective Date 2011 Revision 02, Updated / Edited by Approved Quality Systems Group of the 28 th ITTC 26 th ITTC 2011, Date 09/2016</a>.
</ol>
<br>

<p>This calculator is made with <a href="https://github.com/ucnl/UCNLPhysics">UCNLPhysics</a> free and open source library.
</p>

<hr>
(C) Alek Dikarev, 2020<br>
For bug reports, suggestions and questions, please feel free to <a href="https://github.com/AlekUnderwater">reach me</a><br>


<script type="text/javascript">

  function setFloat(elementID, value, dec) {
    document.getElementById(elementID).innerText = value.toFixed(dec);
  }

  function numInSetErrState(minV, maxV, elementID, disableElementID) {
    var val = parseFloat(document.getElementById(elementID).value);
    if ((val >= minV) && (val <= maxV)) {
      document.getElementById(elementID).style.border.color = "default";
      document.getElementById(disableElementID).disabled = false;
      return true;
    }
    else {
      document.getElementById(elementID).style.border.color = "salmon";
      document.getElementById(disableElementID).disabled = true;
      return false;
    }
  }

  function c1_check_t() { numInSetErrState(-4.0, 40.0, "c1_t_C_input", "c1_run"); }
  function c1_check_P0() { numInSetErrState(890.0, 1085.0, "c1_p0_mBar_input", "c1_run"); }
  function c1_check_P() { numInSetErrState(1E3, 1E6, "c1_P_mBar_input", "c1_run"); }
  function c1_check_phi() { numInSetErrState(-90.0, 90.0, "c1_phi_deg_input", "c1_run"); }
  function c1_check_s() { numInSetErrState(0.0, 42.0, "c1_s_PSU_input", "c1_run"); }

  function c2_check_Np() { numInSetErrState(2, 99999, "c2_N_p_input", "c2_run"); }

  function c3_check_Ntsp() { numInSetErrState(2, 999, "c3_Ntsp_input", "c3_run"); }
  function c3_check_ZStep() { numInSetErrState(1, 1000, "c3_z_step_input", "c3_run"); }


  var arrHead = new Array();
  arrHead = ['Point index', 'Z coordinate', 'Temperature, °C', 'Salinity, PSU'];

  function createTable() {
      var empTable = document.createElement('table');
      empTable.setAttribute('id', 'tsProfileTable');
      var tr = empTable.insertRow(-1);
      for (var h = 0; h < arrHead.length; h++) {
          var th = document.createElement('th');
          th.innerHTML = arrHead[h];
          tr.appendChild(th);
      }
      var div = document.getElementById('cont');
      div.appendChild(empTable);
  }

  function updateTable() {
    var Ntsp = parseFloat(document.getElementById('c3_Ntsp_input').value);
    var z_step = parseFloat(document.getElementById('c3_z_step_input').value);
    var tspTable = document.getElementById('tsProfileTable');

    for (var n = tspTable.rows.length - 1; n > 0; n--) {
      tspTable.deleteRow(n);
    }

    var z = 0;

    for (var x = 0; x < Ntsp; x++) {
      var tr = tspTable.insertRow(x+1);
      for (var c = 0; c < arrHead.length; c++) {
        var td = document.createElement('td');
        td = tr.insertCell(c);

        if (c == 0) {
          td.innerText = x + 1;
        }
        else if (c == 1) {
          td.innerText = (z + z_step * x).toFixed(3);
        }
        else if ((c == 2) || (c == 3)) {
          var ele = document.createElement('input');
          ele.setAttribute('type', 'number');
          ele.setAttribute('step', '0.01');
          ele.setAttribute('value', '0.0');
          td.appendChild(ele);
        }
      }
    }
  }

  function updateTable_And_Set_TS_Const() {
    updateTable();
    t   = parseFloat(document.getElementById("c1_t_C_input").value);
    s   = parseFloat(document.getElementById("c1_s_PSU_input").value);
    set_TS_Profile_Const(t, s);
  }

  function getProfile() {
    var profile = [];
    var tspTable = document.getElementById('tsProfileTable');
    var rowCnt = tspTable.rows.length;

    for (var n = 1; n < rowCnt; n++) {
      var z = parseFloat(tspTable.rows.item(n).cells[1].childNodes[0].textContent);
      var t = parseFloat(tspTable.rows.item(n).cells[2].childNodes[0].value);
      var s = parseFloat(tspTable.rows.item(n).cells[3].childNodes[0].value);
      profile.push({z: z, t: t, s: s });
    }

    return profile;
  }

  function set_TS_Profile_Const(t, s) {

    var tspTable = document.getElementById('tsProfileTable');
    var rowCnt = tspTable.rows.length;

    for (var n = 1; n < rowCnt; n++) {
      tspTable.rows.item(n).cells[2].childNodes[0].value = t;
      tspTable.rows.item(n).cells[3].childNodes[0].value = s;
    }
  }

  function set_TS_Profile(phi, z_step, ts_profile) {
    var p_length = ts_profile.length;
    document.getElementById('c1_phi_deg_input').value = phi;
    document.getElementById('c3_Ntsp_input').value = p_length;
    document.getElementById('c3_z_step_input').value = z_step;
    updateTable();

    var tspTable = document.getElementById('tsProfileTable');
    var rowCnt = tspTable.rows.length;

    for (var n = 1; n < rowCnt; n++) {
      tspTable.rows.item(n).cells[2].childNodes[0].value = ts_profile[n - 1].t;
      tspTable.rows.item(n).cells[3].childNodes[0].value = ts_profile[n - 1].s;
    }
  }

  function set_Example_Northern_pacific_TS_profile() {
    set_TS_Profile(EXAMPLE_N_PACIFIC_TS_PROFILE.latitude,
                   EXAMPLE_N_PACIFIC_TS_PROFILE.zStep,
                   EXAMPLE_N_PACIFIC_TS_PROFILE.tsProfile);
  }

  function set_Example_Southern_Atlantic_TS_profile() {
    set_TS_Profile(EXAMPLE_S_ATLANTIC_TS_PROFILE.latitude,
                   EXAMPLE_S_ATLANTIC_TS_PROFILE.zStep,
                   EXAMPLE_S_ATLANTIC_TS_PROFILE.tsProfile);
  }

  function set_Example_Arctic_TS_profile() {
    set_TS_Profile(EXAMPLE_ARCTIC_TS_PROFILE.latitude,
                   EXAMPLE_ARCTIC_TS_PROFILE.zStep,
                   EXAMPLE_ARCTIC_TS_PROFILE.tsProfile);
  }



  function c1_run() {
    t   = parseFloat(document.getElementById("c1_t_C_input").value);
    p0  = parseFloat(document.getElementById("c1_p0_mBar_input").value);
    p   = parseFloat(document.getElementById("c1_P_mBar_input").value);
    s   = parseFloat(document.getElementById("c1_s_PSU_input").value);
    phi = parseFloat(document.getElementById("c1_phi_deg_input").value);

    rho_p0 = PHX_water_density_calc(t, p0, s);
    rho_p  = PHX_water_density_calc(t, p, s);
    rho_pm = PHX_water_density_calc(t, (p0 + p) / 2, s);

    g = PHX_gravity_constant_WGS84_calc(phi);

    h_swg = PHX_depth_by_pressure_calc(p, p0, PHX_SWTR_DENSITY_KGM3, PHX_GRAVITY_ACC_MPS2);
    h_sw  = PHX_depth_by_pressure_calc(p, p0, PHX_SWTR_DENSITY_KGM3, g);
    h_fwg = PHX_depth_by_pressure_calc(p, p0, PHX_FWTR_DENSITY_KGM3, PHX_GRAVITY_ACC_MPS2);
    h_fw  = PHX_depth_by_pressure_calc(p, p0, PHX_FWTR_DENSITY_KGM3, g);

    h_rho_p0 = PHX_depth_by_pressure_calc(p, p0, rho_p0, g);
    h_rho_p  = PHX_depth_by_pressure_calc(p, p0, rho_p, g);
    h_rho_pm = PHX_depth_by_pressure_calc(p, p0, rho_pm, g);

    setFloat("c1_rho", rho_p, 3);
    setFloat("c1_g", g, 4);
    setFloat("c1_h_swg", h_swg, 3);
    setFloat("c1_h_sw", h_sw, 3);
    setFloat("c1_h_fwg", h_fwg, 3);
    setFloat("c1_h_fw", h_fw, 3);
    setFloat("c1_h_rho_P0", h_rho_p0, 3);
    setFloat("c1_h_rho_P", h_rho_p, 3);
    setFloat("c1_h_rho_Pm", h_rho_pm, 3);

  }

  function c2_run() {
    t   = parseFloat(document.getElementById("c1_t_C_input").value);
    p0  = parseFloat(document.getElementById("c1_p0_mBar_input").value);
    p   = parseFloat(document.getElementById("c1_P_mBar_input").value);
    s   = parseFloat(document.getElementById("c1_s_PSU_input").value);
    phi = parseFloat(document.getElementById("c1_phi_deg_input").value);
    N_p = parseFloat(document.getElementById("c2_N_p_input").value);

    rho_p0 = PHX_water_density_calc(t, p0, s);
    rho_p  = PHX_water_density_calc(t, p, s);
    rho_pm = PHX_water_density_calc(t, (p0 + p) / 2, s);

    g = PHX_gravity_constant_WGS84_calc(phi);

    h_rho_p0 = PHX_depth_by_pressure_calc(p, p0, rho_p0, g);
    h_rho_p  = PHX_depth_by_pressure_calc(p, p0, rho_p, g);
    h_rho_pm = PHX_depth_by_pressure_calc(p, p0, rho_pm, g);

    homogenous_ts_profile = [ { z: 0, t: t, s: s},
                              { z: 10000, t: t, s: s},
                            ];

    h_rho = PHX_depth_by_pressure_ts_profile(p, p0, N_p, g, homogenous_ts_profile);

    setFloat("c2_g", g, 4);
    setFloat("c2_h_rho_P0", h_rho_p0, 3);
    setFloat("c2_h_rho_P", h_rho_p, 3);
    setFloat("c2_h_rho_Pm", h_rho_pm, 3);
    setFloat("c2_h_rho", h_rho, 3);

  }

  function c3_run() {
    ts_profile = getProfile();

    p0  = parseFloat(document.getElementById("c1_p0_mBar_input").value);
    p   = parseFloat(document.getElementById("c1_P_mBar_input").value);
    s   = parseFloat(document.getElementById("c1_s_PSU_input").value);
    phi = parseFloat(document.getElementById("c1_phi_deg_input").value);
    N_p = parseFloat(document.getElementById("c2_N_p_input").value);
    g = PHX_gravity_constant_WGS84_calc(phi);

    h_ts = PHX_depth_by_pressure_ts_profile(p, p0, N_p, g, ts_profile)

    setFloat("c3_h_ts", h_ts, 3);
  }

   c1_run();
   c2_run();

   createTable();
   updateTable_And_Set_TS_Const();
   c3_run();

</script>

</body>
</html>
